<!DOCTYPE html>
<html lang="en">
<head>
    
    <meta charset="utf-8">
    <title>Home - Documentation</title>
    
    
    <script src="scripts/prettify/prettify.js"></script>
    <script src="scripts/prettify/lang-css.js"></script>
    <!--[if lt IE 9]>
      <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
    <link type="text/css" rel="stylesheet" href="styles/prettify.css">
    <link type="text/css" rel="stylesheet" href="styles/jsdoc.css">
    <script src="scripts/nav.js" defer></script>
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
</head>
<body>

<input type="checkbox" id="nav-trigger" class="nav-trigger" />
<label for="nav-trigger" class="navicon-button x">
  <div class="navicon"></div>
</label>

<label for="nav-trigger" class="overlay"></label>

<nav >
    
    <h2><a href="index.html">Home</a></h2><h3>Classes</h3><ul><li><a href="Fields.html">Fields</a><ul class='methods'><li data-type='method'><a href="Fields.html#.boolean">boolean</a></li><li data-type='method'><a href="Fields.html#.choice">choice</a></li><li data-type='method'><a href="Fields.html#.model">model</a></li><li data-type='method'><a href="Fields.html#.number">number</a></li><li data-type='method'><a href="Fields.html#.string">string</a></li></ul></li><li><a href="FileSystemStore.html">FileSystemStore</a><ul class='methods'><li data-type='method'><a href="FileSystemStore.html#deleteRecord">deleteRecord</a></li><li data-type='method'><a href="FileSystemStore.html#loadRecord">loadRecord</a></li><li data-type='method'><a href="FileSystemStore.html#loadSchema">loadSchema</a></li><li data-type='method'><a href="FileSystemStore.html#ready">ready</a></li><li data-type='method'><a href="FileSystemStore.html#saveMigration">saveMigration</a></li><li data-type='method'><a href="FileSystemStore.html#saveRecord">saveRecord</a></li><li data-type='method'><a href="FileSystemStore.html#saveSchema">saveSchema</a></li></ul></li><li><a href="Model.html">Model</a><ul class='methods'><li data-type='method'><a href="Model.html#.create">create</a></li><li data-type='method'><a href="Model.html#.load">load</a></li><li data-type='method'><a href="Model.html#delete">delete</a></li><li data-type='method'><a href="Model.html#get">get</a></li><li data-type='method'><a href="Model.html#reset">reset</a></li><li data-type='method'><a href="Model.html#save">save</a></li><li data-type='method'><a href="Model.html#set">set</a></li><li data-type='method'><a href="Model.html#toForm">toForm</a></li><li data-type='method'><a href="Model.html#toHTMLForm">toHTMLForm</a></li><li data-type='method'><a href="Model.html#toHTMLTable">toHTMLTable</a></li><li data-type='method'><a href="Model.html#toHTMLTableRows">toHTMLTableRows</a></li><li data-type='method'><a href="Model.html#toString">toString</a></li><li data-type='method'><a href="Model.html#toTable">toTable</a></li><li data-type='method'><a href="Model.html#toTableRows">toTableRows</a></li><li data-type='method'><a href="Model.html#updateFromSubmission">updateFromSubmission</a></li><li data-type='method'><a href="Model.html#valueOf">valueOf</a></li></ul></li><li><a href="Models.html">Models</a><ul class='methods'><li data-type='method'><a href="Models.html#.create">create</a></li><li data-type='method'><a href="Models.html#.deleteModel">deleteModel</a></li><li data-type='method'><a href="Models.html#.loadModel">loadModel</a></li><li data-type='method'><a href="Models.html#.register">register</a></li><li data-type='method'><a href="Models.html#.resetRegistrations">resetRegistrations</a></li><li data-type='method'><a href="Models.html#.saveModel">saveModel</a></li><li data-type='method'><a href="Models.html#.setStore">setStore</a></li><li data-type='method'><a href="Models.html#.useDefaultStore">useDefaultStore</a></li></ul></li><li><a href="ModelStore.html">ModelStore</a><ul class='methods'><li data-type='method'><a href="ModelStore.html#deleteRecord">deleteRecord</a></li><li data-type='method'><a href="ModelStore.html#loadRecord">loadRecord</a></li><li data-type='method'><a href="ModelStore.html#loadSchema">loadSchema</a></li><li data-type='method'><a href="ModelStore.html#ready">ready</a></li><li data-type='method'><a href="ModelStore.html#saveMigration">saveMigration</a></li><li data-type='method'><a href="ModelStore.html#saveRecord">saveRecord</a></li><li data-type='method'><a href="ModelStore.html#saveSchema">saveSchema</a></li></ul></li></ul><h3>Namespaces</h3><ul><li><a href="conforms.html">conforms</a><ul class='methods'><li data-type='method'><a href="conforms.html#.conforms">conforms</a></li></ul></li><li><a href="diff.html">diff</a><ul class='methods'><li data-type='method'><a href="diff.html#.apply">apply</a></li><li data-type='method'><a href="diff.html#.applyDiff">applyDiff</a></li><li data-type='method'><a href="diff.html#.create">create</a></li><li data-type='method'><a href="diff.html#.createDiff">createDiff</a></li><li data-type='method'><a href="diff.html#.makeChangeHandler">makeChangeHandler</a></li><li data-type='method'><a href="diff.html#.reverse">reverse</a></li><li data-type='method'><a href="diff.html#.reverseDiff">reverseDiff</a></li></ul></li><li><a href="equals.html">equals</a><ul class='methods'><li data-type='method'><a href="equals.html#.equals">equals</a></li></ul></li><li><a href="Errors.html">Errors</a></li><li><a href="html.html">html</a></li><li><a href="schema.html">schema</a><ul class='methods'><li data-type='method'><a href="schema.html#.createDefault">createDefault</a></li><li data-type='method'><a href="schema.html#.createValidator">createValidator</a></li><li data-type='method'><a href="schema.html#.getModelSet">getModelSet</a></li><li data-type='method'><a href="schema.html#.getRecordNameFor">getRecordNameFor</a></li><li data-type='method'><a href="schema.html#.linkSchema">linkSchema</a></li><li data-type='method'><a href="schema.html#.migrate">migrate</a></li><li data-type='method'><a href="schema.html#.migrate%255E2">migrate^2</a></li><li data-type='method'><a href="schema.html#.unlinkSchema">unlinkSchema</a></li><li data-type='method'><a href="schema.html#.validate">validate</a></li></ul></li><li><a href="tree.html">tree</a></li><li><a href="utils.html">utils</a><ul class='methods'><li data-type='method'><a href="utils.html#.sortedObjectKeys">sortedObjectKeys</a></li></ul></li></ul>
</nav>

<div id="main">
    

    



    


    <section class="package">
        <h3> </h3>		
    </section>









    



    <section class="readme usertext">
        <article><h1 id="documentation-for-this-library">Documentation for this library</h1>
<p>For the pure API docs, see the class navigation on the left. For a general discussion for this library with examples on how to do the things you'd typically want to do, read on.</p>
<h2 id="table-of-contents">Table of contents</h2>
<ul>
<li><a href="#defining-models">Defining models</a>
<ul>
<li><a href="#model-class-definitions">Model class definitions</a></li>
<li><a href="#field-types-and-options">Field types and options</a></li>
<li><a href="#custom-validation">Custom validation</a></li>
</ul>
</li>
<li><a href="#constructing-model-instances">Constructing model instances</a>
<ul>
<li><a href="#examples-of-create">Examples</a></li>
</ul>
</li>
<li><a href="#using-models">Using models</a>
<ul>
<li><a href="#set%2Fget-values-with-automatic-validation">set/get values with automatic validation</a></li>
<li><a href="#set%2Fget-subtrees-with-automatic-validation">set/get subtreees with automatic validation</a></li>
<li><a href="#set%2Fget-with-path-keys">set/get with path kes</a></li>
<li><a href="#converting-to-formatted-json-(with-defaults-omitted)---.tostring()">converting to JSON</a></li>
<li><a href="#converting-to-fully-qualified%2C-plain-js-object---.valueof()">converting to fully qualified plain object</a></li>
<li><a href="#(partially)-resetting-model-instances">(partially) resetting model instances)</a></li>
</ul>
</li>
<li><a href="#using-models-for%2Fin-the-browser">Using models for/in the browser</a>
<ul>
<li><a href="#import/bundling-your-model-definition">import/bundling your model definitions</a>
<ul>
<li><a href="#ignoring-the-default-file-store-for-clientside-work">excluding the default file store for browser bundles</a></li>
</ul>
</li>
<li><a href="#tree-mapping-your-model">Tree-mapping your data</a>
<ul>
<li><a href="#html-form%2Ftable">HTML form/table</a></li>
<li><a href="#(p)react-form%2Ftable">(P)React form/table)</a></li>
<li><a href="#custom-trees">Custom trees</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#using-a-data-store">Using a data store</a>
<ul>
<li><a href="#binding-a-data-store">binding a data store for model use</a></li>
<li><a href="#setting-store-related-metadata-on-your-model-classes">Setting store-related model metadata</a></li>
<li><a href="#awaiting-all-model.create()-calls">awaiting all model <code>create</code> calls</a></li>
<li><a href="#saving-models-to-the-store">saving model instances</a></li>
<li><a href="#loading-models-from-the-store">loading model instances</a></li>
<li><a href="#deleting-models-from-the-store">deleting stored model instances</a></li>
<li><a href="#updating-your-model-definitions">updating your model definitions</a></li>
<li><a href="#schema-change-detection">schema change detection</a></li>
</ul>
</li>
<li><a href="#data-migrations-using-the-%7B%40link-filesystemstore%7D">data migrations using the filesystem store</a>
<ul>
<li><a href="#editing-the-migration-runner-hooks">editing the migration hooks</a>
<ul>
<li><a href="#caching-values-during-a-migration">caching values during a migration</a></li>
</ul>
</li>
<li><a href="#dry-running-a-migration">dry-running a migration</a></li>
<li><a href="#remember-to-run-version-control-on-your-data-directory">remember to use version control</a></li>
</ul>
</li>
</ul>
<h2 id="defining-models">Defining models</h2>
<p>In order to use models for data, the library needs you to define classes that extend <a href="Model.html">Model</a>, which can then be used to wrap data.</p>
<h3 id="model-class-definitions">Model class definitions</h3>
<p>The simplest, valid Model extension is one that declares all its fields, and nothing else:</p>
<pre class="prettyprint source lang-javascript"><code>class YourModel extends Model {
  fieldname1 = Fields.fieldType(...);
  fieldname2 = Fields.fieldType(...);
  ...
}
</code></pre>
<p>However, it's generally a better idea to also specify metadata, using the <code>__meta</code> property.</p>
<pre class="prettyprint source lang-javascript"><code>class YourModel extends Model {
  __meta = {
    ...
  }

  fieldname1 = Fields.fieldType(...);
  fieldname2 = Fields.fieldType(...);
  ...
}
</code></pre>
<p>This metadata may contain:</p>
<ul>
<li><code>name</code> - the model's name</li>
<li><code>description</code> - a description of what this class models</li>
<li><code>distinct</code> - if <code>true</code>, this model counts as &quot;a thing that can be stored&quot; when using a data store.</li>
<li><code>recordName</code> - if <code>distinct</code> is <code>true</code>, this property is used to determine the storage key for model instances, either as a path key (indicating which single field somewhere in the mode counts as identifier) or as a mapping function <code>(instance) =&gt; string</code>.</li>
</ul>
<h3 id="field-types-and-options">Field types and options</h3>
<p>The <a href="Fields.html">Fields</a> class defines several field types that you can use to build out your models.</p>
<ul>
<li><code>boolean(options?)</code>, for true/false values</li>
<li><code>number(options?)</code>, for numerical values</li>
<li><code>string(options?)</code>, for string data</li>
<li><code>choice(values[], options)</code>, for values that can only be one of a predefined list of values.</li>
<li><code>model(modelClass, options)</code>, for submodels (e.g. if it's an object in plain data, it's just another model).</li>
</ul>
<p>Also note that arrays of values (e.g. a field called <code>photos</code> being an array of <code>Photo</code> submodels) are not a separate field type, instead these simply rely on you passing in the <code>array: true</code> property as part of the field options.</p>
<pre class="prettyprint source lang-javascript"><code>class User extends Model {
  photos = Fields.model(Photo, { array: true });
}

class Photo extends Model {
  filename = Fields.string({ validate: ... });
  width = Fields.number(...);
  height = Fields.number(...);
  ...
}
</code></pre>
<p>The full list of properties that can be passed in <code>options</code> is:</p>
<ul>
<li><code>required</code>: a boolean value that determines whether the field must always have a value</li>
<li><code>default</code>: a default value to use when the field has not been explicitly assigned</li>
<li><code>choices</code>: an array of possible values that this field may take (note that <code>Fields.choice(...)</code> is typically preferred for this)</li>
<li><code>configurable</code>: a boolean value that determines whether this field may be presented to the user as editable (i.e. when showing the data in an edit form)</li>
<li><code>debug</code>: a boolean value that regulates whether fields are included in the model when the library is running in debug mode.</li>
<li><code>validate</code>: a function for performing more elaborate validation than basic type validation can offer.</li>
</ul>
<h3 id="custom-validation">Custom validation</h3>
<p>The <code>validate</code> property takes a function that takes the to-validate value as input argument, and must fail in one of two ways if the value is invalid. The function must:</p>
<ul>
<li>return <code>false</code>, or</li>
<li>throw an <code>Error</code> object.</li>
</ul>
<p>The first is for &quot;simple failures&quot;, where the validation fails without any details:</p>
<pre class="prettyprint source lang-javascript"><code>class Something extends Model {
  //...
  legalAge = Fields.number({
    validate: (value) => value >= 18,
  });
}
</code></pre>
<p>The second is for when more elaborate details are required.</p>
<pre class="prettyprint source lang-javascript"><code>import imagelib from &quot;some-image-lib&quot;;

class Something extends Model {
  //...
  avatar = Fields.string({
    validate: value => checkBase64Image(value, `avatar`),
  });
}

function checkBase64Image(data, fieldName) {
  const details = imagelib.verify(data);
  if (!details.ok) {
    throw new ImageVerificationError(fieldName, details);
  }
}

class ImageVerificationError extends Error {
  constructor(fieldName, errorDetails) {
    const { errorCode } = errorDetails;
    this.message =  `${fieldName} was not a valid base64-encoded image (error code: ${errCode}).`;
    this.details = errorDetails;
  }
}
</code></pre>
<h2 id="constructing-model-instances">Constructing model instances</h2>
<p><a href="Model.html">Model</a> instances are created using the <code>create</code> function:</p>
<ul>
<li><code>Model.create(data?, Model.ALLOW_INCOMPLETE?)</code> where <code>Model</code> is your model class, and <code>data</code> is a required object with one or more values to be used to bootstrap the model instance.</li>
</ul>
<p>The <code>ALLOW_INCOMPLETE</code> static symbol is used by the library to determine whether or not incompletely model creation is allowed. That is, if not specified, trying to create a model without provided values for required fields will throw a <a href="Errors.html#.RequiredFieldsMissing">Errors.RequiredFieldsMissing</a> error.</p>
<p>Also note that in addition to normal JS objects, you may also provide key-pathed objects. That is, while <code>create</code> accepts standard objects like this:</p>
<pre class="prettyprint source lang-javascript"><code>{
  key1: {
    subkey: {
      fieldname: value
    },
    keyfield: value
  },
  key2: {
    something: value
  },
}
</code></pre>
<p>It also allows you to specify data using a &quot;flat&quot; objects, with dot-separated path keys instead of nesting:</p>
<pre class="prettyprint source lang-javascript"><code>{
  &quot;key1.subkey.fieldname&quot;: value,
  &quot;key1.keyfield&quot;: value,
  &quot;key2.something&quot;: value,
}
</code></pre>
<p>This is especially useful when dealing with flat data delivery mechanisms such as form submissions or flat-record storage back ends.</p>
<h3 id="examples-of-create">Examples of <code>create</code></h3>
<pre class="prettyprint source lang-javascript"><code>import { Errors } from &quot;use-models-for-data&quot;;
import { User } from &quot;./my-models.js&quot;;
const { RequiredFieldsMissing } = Errors;

// missing username or password:
const user1 = User.create(User.ALLOW_INCOMPLETE);

// missing password:
const user2 = User.create({
  name: `Tester McTesting`,
}, User.ALLOW_INCOMPLETE);

try {
  // This will throw
  const user2 = User.create();
} catch (e) {
  if (e instanceof RequiredFieldsMissing) {
    // this is unexpected, but a known possible failure state.
    console.error(e);
  } else if (...) {
    ...
  }
}

try {
  // This will also throw
  const user3 = User.create({
    name: `Tester McTesting`,
  });
} else {
  // see &quot;strict create&quot;, above.
}
</code></pre>
<h2 id="using-models">Using models</h2>
<p>With your data encoded as a model instance, you can now treat it like any other plain JS object, referencing and assigning values as usual. However, assignments may throw, as <em>all assignments</em> are locked behind validation, including entire subtree assignments.</p>
<h3 id="set%2Fget-values-with-automatic-validation">Set/get values with automatic validation</h3>
<p>Everything should work exactly the same as if your model was a plain object:</p>
<pre class="prettyprint source lang-javascript"><code>import Errors from &quot;use-models-for-data&quot;;
const { InvalidAssignment } = Errors;

class User extends Model {
  name = Fields.string({ required: true });
  password = Fields.string({ required: true, validate: ... });
}

const user = User.create({ name: ..., password: ... });

try {
  user.name = `A new name`;
  user.password = `A new password`;
} catch (e) {
  if (e instanceof InvalidAssignment) {
    console.error(e);
  } else if (...) {
    ...
  }
}
</code></pre>
<h3 id="set%2Fget-subtrees-with-automatic-validation">Set/get subtrees with automatic validation</h3>
<p>Even when setting entire subtrees, things should still work as expected:</p>
<pre class="prettyprint source lang-javascript"><code>import Errors from &quot;use-models-for-data&quot;;
const { InvalidAssignment } = Errors;

class ComplexModel extends Model {
  /*
   Some class that models {
     key1: {
       subkey: {
         fieldname: value
       },
       keyfield: value
     },
     key2: {
       something: value
     }
   }
  */
}

const instance = ComplexModel.create();

try {
  instance.key1 = {
    subkey: {
      fieldname: &quot;test&quot;,
    },
    keyfield: 1234,
  };
} catch (e) {
  if (e instanceof InvalidAssignment) {
    console.error(e);
  } else if (...) {
    ...
  }
}
</code></pre>
<h3 id="set%2Fget-with-path-keys">Set/get with path keys</h3>
<p>In addition to getting and setting properties like you would for any JS object, models also support <code>.get(pathkey)</code> and <code>.set(pathkey, value)</code>, for getting/setting nested properties using keys with <code>.</code> delimiters:</p>
<pre class="prettyprint source lang-javascript"><code>const complexInstance = ComplexModel.create(...);
const fieldKey = `key1.subkey.fieldname`;

let fieldValue = complexInstance.get(fieldKey);
fieldValue = `${fieldValue}-plus`;
complexInstance.set(fieldKey, fieldValue);
</code></pre>
<h3 id="converting-to-formatted-json-(with-defaults-omitted)---.tostring()">Converting to formatted JSON (with defaults omitted) - <code>.toString()</code></h3>
<p>Any model instance can be turned into JSON (with sorted keys at all depths) by using its <code>.toString()</code> function. However, because model instances are backed by a model definition that may contain default values for anything that isn't explicit set, this JSON will not include any of those default values, only encoding real values. As such, the following model:</p>
<pre class="prettyprint source lang-javascript"><code>class User extends Model {
  name = Fields.string({ required: true });
  password = Fields.string({ required: true, validate: ... });
  postCount = Fields.number({ default: 0 })
  rewards = Fields.number({ default: 0 })
  level = Fields.number({ default: 1 })
}
</code></pre>
<p>Will turn into a JSON object with only a name and password using <code>.toString()</code> unless any of the fields with default values were set to a non-default value prior to <code>.toString()</code>:</p>
<pre class="prettyprint source lang-javascript"><code>const user = User.create({ name: &quot;Tester McTesting&quot;, password: &quot;abcdef&quot; });
user.level = 2;

console.log(user.toString());
/*
  {
    &quot;level&quot;: 2,
    &quot;name&quot;: &quot;Tester McTesting&quot;,
    &quot;password&quot;: &quot;abcdef&quot;
  }
*/
</code></pre>
<h3 id="converting-to-fully-qualified%2C-plain-js-object---.valueof()">Converting to fully qualified, plain JS object - <code>.valueOf()</code></h3>
<p>To generate a fully qualified object (e.g. when needing to send the model off to something that does <em>not</em> use models for data) the <code>.valueOf()</code> function can be used to turn any model instance into a plain JS object. If you've written your code right, you should never need to use this function. But if you absolutely <em>do</em> need it, it's there.</p>
<p>Using the above <code>User</code> model:</p>
<pre class="prettyprint source lang-javascript"><code>const user = User.create({ name: &quot;Tester McTesting&quot;, password: &quot;abcdef&quot; });
const unsafe = user.valueOf();
console.log(JSON.stringify(unsafe));
/*
  {
    &quot;name&quot;: &quot;Tester McTesting&quot;,
    &quot;password&quot;: &quot;abcdef&quot;,
    &quot;postCount&quot;: 0,
    &quot;rewards&quot;: 0,
    &quot;level&quot;: 2
  }
*/
</code></pre>
<h3 id="(partially)-resetting-model-instances">(Partially) resetting model instances</h3>
<p>Sometimes it's necessary to not just &quot;set some values&quot; but also &quot;unset previously set values&quot;. Rather than having to write the following code, in which we can reassign our user variable, leading to the possibility of all kinds of fun bugs:</p>
<pre class="prettyprint source lang-javascript"><code>let user1 = User.create({ ... });
const { name, password, level } = user1;
user1 = User.create({ name, password, level});
</code></pre>
<p>You can use the <code>.reset()</code> function, with an optional object for reassigning some (or all) fields some new data, without having to declare new variables, and without allowing redefining <code>user</code>, thus making sure that it will always be a validating model instance.</p>
<pre class="prettyprint source lang-javascript"><code>const user = User.create({ ... });
const { name, password, level } = user;
user.reset({ name, password, level});
</code></pre>
<p>Although of course, if you want immutable code, you will almost certainly not want to use <code>reset()</code>, instead just making explicit, new model instances:</p>
<pre class="prettyprint source lang-javascript"><code>function furtherProcess(user) {
  // ...
}

const user1 = User.create({ ... });
const { name, password, level } = user1;
furtherProcess(User.create({ name, password, level}));
</code></pre>
<h2 id="using-models-for%2Fin-the-browser">Using models for/in the browser</h2>
<p>Models wouldn't be very useful if you could only use them server-side: you can use models for data anywhere that you can use (modern) Javascript.</p>
<h3 id="import%2Fbundling-your-model-definition">Import/bundling your model definition</h3>
<p>When writing client-side JS, all you need to do is import your classes as usually, and let your bundler (for modern JS) take care of the rest. This way your client and server will be &quot;speaking the same models&quot; no matter how much you update them.</p>
<p>In fact, even if you don't even have &quot;a server&quot; and you just write client-side code that works ith API responses from other places on the web, you will be able to just bundle up your client with model functionality included.</p>
<h4 id="ignoring-the-default-file-store-for-clientside-work">ignoring the default file store for clientside work</h4>
<p>The one thing to take note of is that <code>use-models-for-data</code> ships with a default filesystem store to make &quot;just writing something that works&quot; much easier. However, as this store relies on <code>path</code> and <code>fs</code>, and your client side code can't use Node's <code>path</code> and <code>fs</code>, you'll need to tell your bundler to ignore this store file.</p>
<p>For example, if you're using an npm script that uses <code>esbuild</code> for bundling, you'd want:</p>
<pre class="prettyprint source lang-json"><code>{
  &quot;scripts&quot;: {
    ...
    &quot;bundle:client&quot;: &quot;esbuild ... --external:./node_modules/use-models-for-data/lib/models/store/filesystem-store.js&quot;,
    ...
  }
}
</code></pre>
<h3 id="tree-mapping-your-model">Tree mapping your model</h3>
<p>While updating models using code makes a ton of sense server-side, if your code also has a client-side component, you probably want to offer users a way to work with (some) models, too.</p>
<p>For instance, you might have a <code>Profile</code> model, parts of which your users should be able to update client-side. You can, of course, roll your own code for turning a model into something editable (after all, model instances behave like any other plain JS object, so that's really not that much work) but if you just want something that will automatically generate you full-model forms then you're in luck because that's something this library also offers.</p>
<p>All element-building is based on walking your model as a data tree, turning leaves and non-leaves into meaningful data, with an options object to control things like pre/post code, value update handling, etc. See the <a href="#custom-trees">custom trees</a> section below for the full description of this process.</p>
<h4 id="html-form%2Ftable">HTML form/table</h4>
<p>Since the browser mostly cares about HTML code, models have code in place to automatically generate <code>&lt;form&gt;</code> and <code>&lt;table&gt;</code> elements for working with model data using standard HTML form fields, in addition to being able to generate a &quot;bare&quot; set of <code>&lt;tr&gt;</code> table rows for slotting into your own HTML template.</p>
<ul>
<li><code>toHTMLForm(options?)</code>: generates a <code>&lt;form&gt;</code> element with nested data wrapped as <code>&lt;fieldset&gt;</code> elements.</li>
<li><code>toHTMLTable(options?)</code>: generates a <code>&lt;table&gt;</code> element as a flat representation of your model data.</li>
<li><code>toHTMLTableRows(options?)</code>: only generates the set of <code>&lt;tr&gt;</code>, with each row corresponding to one leaf of your model's data tree.</li>
</ul>
<p>Using these is about as close to no work as possible:</p>
<pre class="prettyprint source lang-javascript"><code>import { User } from &quot;../src/models/user.js&quot;;

// ...

function generateUserForm(user) {
  document.querySelector(`#modal .form-panel`)?.innerHTML = user.toHTMLForm();
}

// ...

editButton.addEventListener(`click`, evt => generateUserForm(evt));
</code></pre>
<p>Of course, while models can perform data validation, they don't automatically test whether data is web-safe, so as always: when working with user data, <code>innerHTML</code> is rarely safe, and you may want to use a sanitizer to verify on that HTML.</p>
<p>For a more secure version, generating the content using the generic <a href="#custom-trees">custom tree</a> approach will generally be a better idea.</p>
<h4 id="(p)react-form%2Ftable">(P)React form/table</h4>
<pre class="prettyprint source lang-jsx"><code>import { Component, createElement } from &quot;(p)react&quot;;
import { User as UserModel } from &quot;./src/models/user.js&quot;;

class UserProfile extends Component {
  constructor(props) {
    super(props);
    this.user = UserModel.create(this.props.userData);
  }

  render() {
    return (
      &lt;>
        &lt;h2>Edit profile&lt;/h2>
        {this.buildProfileForm()}
      &lt;/>
    );
  }

  buildProfileForm() {
    const tableOptions = {
      create: createElement,
      inputHandler: {
        onInput: (evt) => {
          const { name, type, checked, value } = evt.target;
          const newValue = type === `checkbox` ? checked : value;
          try {
            // As form elements use path-keys for input names,
            // we use the .set() function to assign the updated
            // value to our model.
            this.user.set(name, newValue);
          } catch (e) {
            // Warn the user about invalid data, either
            // via an effect, a state update, a modal,
            // etc.
          }
        },
      },
    };

    return (
      &lt;table ref={(e) => (this.profileTable = e)}>
        {this.user.toTableTree(tableOptions)}
      &lt;/table>
    );
  }
}
</code></pre>
<h4 id="custom-trees">Custom trees</h4>
<p>If you're using a tech stack that isn't explicitly covered by this library, you can relatively easily write your own &quot;tree serializer&quot; using the same approach as used when using (P)React, where you specify the key elements required for the tree conversion, and the code does the rest. This is done by passing in an options object to the <code>.toForm()</code>, <code>.toTable()</code>, or <code>.toTableRows()</code> function, which can be giving the following properties:</p>
<ul>
<li><code>create: function(tag, options)</code>: a function that turns a tag-and-options tuple into whatever nestable data structure is required for your tech stack to work.</li>
<li><code>footer</code>: any kind of content that you need added to the end (only applies to <code>form</code> and <code>table</code> generation),</li>
<li><code>label: function(key)</code>: a function that turns a field value's path key into something useful (like turning <code>key1.fieldvalue</code> into <code>Key1 fieldvalue</code>).</li>
<li><code>skipDebug</code>: boolean, omits all model fields marked as <code>debug</code> from the resulting data structure.</li>
<li><code>inputHandler</code>: an object that gets dereferenced when processing all child nodes, adding its content as child property for input handling. For example, for (P)React this would be <code>{ onInput: evt =&gt; { ... }}</code>, so that elements end up being some <code>&lt;InputElement onInput={evt =&gt; ... }/&gt;</code>.</li>
</ul>
<p>In addition to this, you can tack any additional properties you need for your data structures. For example, (P)React triggers an <code>onSubmit</code> when a form is submitted, and so adding an <code>onSubmit</code> property to the options object with a handling function will automatically cause that to kick in.</p>
<h2 id="using-a-data-store">Using a data store</h2>
<p>Using models to ensure your data is always valid also requires knowing that your models themselves are synced between the various parts of your code, as well as between your storage backend(s) and your code. As such, this library lets you basically use any backend you like, as long as you can write a <a href="ModelStore.html">ModelStore</a> for it.</p>
<p>The library comes with a single ModelStore implementation predefined, the <a href="FileSystemStore.html">FileSystemStore</a>, which uses your local filesystem as a storage backend.</p>
<h3 id="binding-a-data-store">Binding a data store</h3>
<p>Use the <code>Models.setStore</code> function:</p>
<pre class="prettyprint source lang-javascript"><code>import { Models } from &quot;use-models-for-data&quot;;
import { MyDataStore } from &quot;./src/store/my-data-store.js&quot;;

Models.useStore(new MyDataStore());
</code></pre>
<p>If you just want to use the file system, there is a dedicated <code>useDefaultStore</code> function that takes a file system path as argument and builds an implicit <a href="FileSystemStore.html">FileSystemStore</a>. Note that this is an <code>async</code> function, and so either needs <code>await</code>ing, or <code>.then(...)</code> handling:</p>
<pre class="prettyprint source lang-javascript"><code>import { Models } from &quot;use-models-for-data&quot;;

// Either use async/await:
async function setup() {
  await Models.useDefaultStore(`./data-store`);
  // ...
}

// Or promise handling:
Models.useDefaultStore(`./data-store`)
.then(() = {
  // ...
})
.catch(err => {
  // ...
})
</code></pre>
<h3 id="setting-store-related-metadata-on-your-model-classes">Setting store related metadata on your Model classes</h3>
<p>In order to use a data store with your models, you need to make sure that your model classes specify a few property in their <code>__meta</code> object. And of course, if you didn't specify one before, you'll have to add one:</p>
<pre class="prettyprint source lang-javascript"><code>class MyModel extends Model {
  __meta = {
    name: `...`,
    distinct: true,
    recordName: pathkey string, or function
  }
}
</code></pre>
<p>The <code>name</code> property is used to name the auto-generated schema that is associated with your model, the <code>distinct</code> property must be set to <code>true</code>, which tells the library that instances of this model can be saved as distinct records in whatever backend is involved, and the <code>recordName</code> property lets the library determine the &quot;key&quot; with which to save your model instances. This is explained in more detail in the <a href="#saving-models-to-the-store">&quot;saving models to the store&quot;</a> section.</p>
<h3 id="awaiting-all-model.create()-calls"><code>await</code>ing all <code>Model.create()</code> calls</h3>
<p>When using a model store, all schema and record operations are necessarily asynchronous, and so one thing that changes is that <code>Model.create</code> will no longer work synchronously, instead returning a promise that you will either need to <code>await</code>, or resolve with <code>.then(instance =&gt; ...).catch(err =&gt; ...)</code> chaining.</p>
<pre class="prettyprint source lang-javascript"><code>// await inside an async code path:
async function() {
  try {
    const user = await User.create(...)
  } catch(err) {
    // ...
  }
}

// using Promise syntax:
Config.create(...)
.then(config => {
  // ...
})
.catch(err => {
  // ...
});
</code></pre>
<h3 id="saving-models-to-the-store">Saving models to the store</h3>
<p>With a store set up, saving a model is literally just a matter of calling <code>save</code>:</p>
<pre class="prettyprint source lang-javascript"><code>const user = await User.create(...);

//...

await user.save();
</code></pre>
<p>This will save the user based on their schema (inherent to your model class) and your model-indicated <code>__meta.recordName</code> property. This can either be a path key to resolve on the instance, such as:</p>
<pre class="prettyprint source lang-javascript"><code>class User extends Model {
  __meta = {
    name: `users`,
    recordName: `profile.name`
  };
  profile = Fields.model(Profile);
}

class Profile extends Model {
  name = Fields.string();
}

const user = await User.create({ profile: { name: &quot;Tester McTesting&quot; }});
await user.save();
</code></pre>
<p>In this example, the user will get saved keyed on both its schema name (&quot;users&quot;) and its recordName, which is the <code>user.profile.name</code> value (in this case, &quot;Tester McTesting&quot;).</p>
<p>Alternatively, you can declare a function for the recordName, which takes the model instance as argument and returns a string:</p>
<pre class="prettyprint source lang-javascript"><code>class User extends Model {
  __meta = {
    name: `users`,
    recordName: function(instance) {
      return instance.profile.name;
    }
  };
  profile = Fields.model(Profile);
}

//...

const user = await User.create({ profile: { name: &quot;Tester McTesting&quot; }});
await user.save();
</code></pre>
<p>This has the same effect as above, but with more control over what exact identifier to generate.</p>
<h3 id="loading-models-from-the-store">Loading models from the store</h3>
<p>Loading models is about as easy as saving: once you've saved a model, you can load it by using its associated recordName as argument to the load function:</p>
<pre class="prettyprint source lang-javascript"><code>const user = await User.load(`Tester McTesting`);
</code></pre>
<h3 id="deleting-models-from-the-store">Deleting models from the store</h3>
<p>Deleting models from the store is a matter of calling <code>delete</code>:</p>
<pre class="prettyprint source lang-javascript"><code>const user = await User.load(`Tester McTesting`);
await user.delete();
</code></pre>
<h3 id="updating-your-model-definitions">Updating your model definitions</h3>
<p>Models aren't write-once, use-forever, they are write-once, then-update, then-update-again, and you don't want to have to manually update all your data just because your model changed. As such, when using a data store, this library turns on change tracking for models, to help with the task of making sure your data is always consistent with respect to your models.</p>
<p>Let's look at an example, with our basic user model:</p>
<pre class="prettyprint source lang-javascript"><code>class User extends Model {
  __meta = {
    name: `users`,
    distinct: true,
    recordName: `name`,
  };
  name = Fields.string({ required: true });
  password = Fields.string({ required: true, validate: ... });
}
</code></pre>
<p>And your model works well enough for a month or two, you have a bunch of users created, everything's been working out great but then you realise that maybe that name/passsword combination is better off inside a profile, with the user itself reserved for more of an &quot;aggregator&quot; role, so you change your model:</p>
<pre class="prettyprint source lang-javascript"><code>class User extends Model {
  __meta = {
    name: `users`,
    distinct: true,
    recordName: `profile.name`,
  };
  admin = Fields.boolean({ default: false });
  profile = Fields.model(Profile);
}

class Profile extends Model {
  __meta = {
    name: `profiles`,
    distinct: false,
  };
  name = Fields.string({ required: true });
  password = Fields.string({ required: true, validate: ... });
}
</code></pre>
<p>And even if you only have a handful of users, having to update all of them manually quickly starts to take up a prohibitive amount of work. To the point where if the changes are big enough, you may be tempted to just not update your models, and that would be terrible, because your tooling should help make this step easy.</p>
<h3 id="schema-change-detection">Schema change detection</h3>
<p>With a data store in place, the library will see that the model you're trying to load doesn't actually match the schema that was saved previously, and will halt your code run:</p>
<pre class="prettyprint source"><code>SchemaMismatchForModel [Error]: Schema mismatch for User model, please migrate your data first.
    at ModelRegistry.recordModelClassWithStoreBacking (file:///.../node_modules/use-models-for-data/lib/models/model-registry.js:164:13)
    at async ModelRegistry.recordModelClassAsync (file:///.../node_modules/use-models-for-data/lib/models/model-registry.js:60:5)
    at async Function.__registerAsync (file:///.../node_modules/use-models-for-data/lib/models/models.js:80:7)
    at somewhere in our file
  modelName: 'User'
}
</code></pre>
<p>Depending on the store you're using this may do different things, but with the default <a href="FileSystemStore.html">FileSystemStore</a> this error will be preceded by a migration runner notice:</p>
<pre class="prettyprint source"><code>╔════════════════════════════════════════════════════════════════════════════════╗
║ Migration saved, run using &quot;node your-data-store-path/users/users.v1.to.v2.js&quot; ║
╚════════════════════════════════════════════════════════════════════════════════╝
</code></pre>
<p>The <a href="FileSystemStore.html">FileSystemStore</a> will automatically create a (node) executable that you can run to automatically uplift your data to the new model, either uplifting specific files as part of your own scripts, or uplifting your entire model directory in a single go.</p>
<p>To help you out, it comes with a nicely detailed help text when you run it without any target:</p>
<pre class="prettyprint source"><code>$ node ./your-data-store-path/users/users.v1.to.v2.js

Autogenerated executable runner for migrating data based on the
&quot;users&quot; schema from version 1 to version 2.

╔═══════════════════════════════════════════════════════════════════════════╗
║ A number of change handler functions have been included, which are called ║
║ during the migration process, and can be implemented to perform data      ║
║ processing outside of the migration itself.                               ║
╚═══════════════════════════════════════════════════════════════════════════╝

Usage:

  1. node users.v1.to.v2.js targefile.json
  2. node users.v1.to.v2.js targefile.json --write
  3. node users.v1.to.v2.js targetdirectory --all

Mode 1: if a target file is indicated, the migration script will load in
the file and migrate its data, outputting the result to stdout

Mode 2: If the &quot;--write&quot; flag is provided, no data will be written to
stdout, instead rewriting the file itself in place.

Mode 3: If the &quot;--all&quot; flag is provided in combination with a directory
path, the script will load all .json files in the indicated directory and
process them as if running in mode 2.

Rollback usage:

  node users.v1.to.v2.js [...] --rollback

All three modes can be made to roll back a migration by using the
&quot;--rollback&quot; flag, which will rollback each step in the list of diff
operations, running them last-to-first.
</code></pre>
<h2 id="data-migrations-using-the-%7B%40link-filesystemstore%7D">Data migrations using the <a href="FileSystemStore.html">FileSystemStore</a></h2>
<p>As mentioned, migrations take the form of executable migration runners, which uplift data by running through a sequence of operational transformations, with hooks that may be used to augment the base diffing behaviour.</p>
<h3 id="editing-the-migration-runner-hooks">Editing the migration runner hooks</h3>
<p>Before running a migration, it's a good idea to open the migration runner in your editor, because there will be times where your help is needed to make sure the migration does the right thing. For example, the differ is not not super great at detecting &quot;relocations&quot; (yet which means that if you know you just moved a property from one part of the model to another part, you may see this reflected in the list of operations as separate <code>remove</code> and <code>add</code> operations. If we ran that migration without intervention, we'd end up losing data, and that's no good.</p>
<p>All hooks take the form <code>function operationForKey(object, operation, options)</code>, where the parameters represent:</p>
<ul>
<li><code>object</code> - the object representation of the data we're uplifting,</li>
<li><code>operation</code> - the diff operation that has been, or will be, applied,</li>
<li><code>options</code> - an object with additional values that may be useful for the hook's specific operation</li>
</ul>
<p>Where hooks are called before the operation gets performed, <em>except</em> for the <code>add</code> operation, which has a hook that gets called <em>after</em> the operation gets performed.</p>
<p>All operations contain:</p>
<ul>
<li><code>type</code> - the kind of operation: <code>add</code>, <code>remove</code>, <code>update</code>, <code>rename</code>, and <code>move</code>.</li>
<li><code>key</code> - the path key to which this operation applies.</li>
<li><code>value</code> - the Schema value (not data value) involved
<code>fn</code> - the name of the hook</li>
</ul>
<p>And the <code>options</code> for each operation are:</p>
<ul>
<li><code>add</code>, <code>remove</code>, and <code>update</code>: An object of the form <code>{ level, propName }</code> where <code>level</code> is the (sub)tree in our data object where the change will be made, and <code>propName</code> is the name of the property in that (sub)tree.</li>
<li><code>rename</code> and <code>move</code>: An object of the form <code>{ oldKey, key, oldPosition, newPosition }</code>, where <code>oldKey</code> is current path key based on the old schema, <code>key</code> is the new path key based on the updated schema, and <code>oldPosition</code> and <code>newPosition</code> are the relative (sub)trees for those path keys.</li>
</ul>
<h4 id="caching-values-during-a-migration">Caching values during a migration</h4>
<p>In order to correctly move data during a migration, there is a <code>cache</code> object that has <code>set(key, value)</code> and <code>get(key)</code> methods so that you can make sure no data gets lost. For example, uplifting data from a schema <code>User { name, password }</code> to a schema <code>User { profile }</code> + <code>Profile { name, password }</code> will result in two <code>remove</code> operations for <code>name</code> and <code>password</code>, and one <code>add</code> operation for <code>profile</code>. In order to make sure the old data makes it into the new spot, we can update the hook functions as follows:</p>
<pre class="prettyprint source lang-javascript"><code>changeHandler.removeName = function (object, op, options) {
  // This runs before the actual removal is applied, giving
  // us time to cache the value for restoring later.
  cache.set(`name`, object.name);
};

changeHandler.removePassword = function (object, op, options) {
  // And the same is true here.
  cache.set(`password`, object.password);
};

changeHandler.addProfile = function (object, op, options) {
  // Finally, this hook runs after the profile has been added,
  // so we can safely restore the values we cached above.
  object.profile.name = cache.get(`name`);
  object.profile.password = cache.get(`password`);
};
</code></pre>
<p>Also note that in order to make sure that this kind of &quot;manual intervention&quot; is always possible, operations will always run all <code>remove</code> operations first, then all <code>rename</code> operations, then all <code>update</code> operations, then all <code>add</code> operations, and finally all <code>move</code> operations.</p>
<h3 id="dry-running-a-migration">Dry-running a migration</h3>
<p>Before running your migrations in place, overwriting all data so that your code can run again, remember to dry-run your migration first by using:</p>
<pre class="prettyprint source"><code>$ node ./your/data/store/metaname/metaname.vN.to.vM.js ./your/data/store/metaname/some-object.json
</code></pre>
<p>This will apply a migration but write the result to <code>stdout</code> rather than back to the same file, so you can verify that the result is indeed what it should be. If the migration does not yield a valid object (based on a schema validation check after uplifting) the script will let you know. For example, if we run the above migration running without updating the migration hooks, the dry run output will be:</p>
<pre class="prettyprint source lang-bash"><code>$ node ./your/data/store/users/users.v1.to.v2.js ./your/data/store/users/some-user.json
ERROR: Migrated data did not pass schema validation.
Please fill in the migration hooks to resolve the following errors:
[
  'profile.name: required field missing.',
  'profile.password: required field missing.'
]
</code></pre>
<p>Whereas with our migration hook code in place, we would get:</p>
<pre class="prettyprint source lang-bash"><code>$ node ./your/data/store/users/users.v1.to.v2.js ./your/data/store/users/some-user.json
{
  &quot;profile&quot;: {
    &quot;name&quot;: &quot;our previous name value&quot;,
    &quot;password&quot;: &quot;some previous password value&quot;
  }
}
</code></pre>
<p>Do note, of course, that default values are not saved to file, which also means that any subtrees consisting purely of default value leaves (or further subtrees) will not show up during a data migration, unless you made sure to put non-default values into them using the migration hooks.</p>
<h3 id="remember-to-run-version-control-on-your-data-directory">Remember to run version control on your data directory</h3>
<p>And on a final note, while you should of course never (well okay, <em>almost</em> never) include your data directory in your project's version-control-managed set of paths, you <em>should</em> make sure to initialise your data directory for local-only version control, because being able to say &quot;wow that migration went all kinds of wrong, let me just reset the dir to what it was before I ran the migration&quot; is the kind of peace of mind you owe to yourself.</p>
<p>If you use git, simply run <code>git init</code> in your data directory, even if that directory is in your project's <code>.gitignore</code> (as it should be), and you can now trivially run commits specific for your data directory, independently of your actual project.</p></article>
    </section>






    
    
</div>

<br class="clear">

<footer>
    Documentation generated by <a href="https://github.com/jsdoc3/jsdoc">JSDoc 3.6.7</a> on Wed Nov 10 2021 22:25:09 GMT-0800 (Pacific Standard Time) using the <a href="https://github.com/clenemt/docdash">docdash</a> theme.
</footer>

<script>prettyPrint();</script>
<script src="scripts/polyfill.js"></script>
<script src="scripts/linenumber.js"></script>



</body>
</html>