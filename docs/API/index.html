<!DOCTYPE html>
<html lang="en">
<head>
    
    <meta charset="utf-8">
    <title>Home - Documentation</title>
    
    
    <script src="scripts/prettify/prettify.js"></script>
    <script src="scripts/prettify/lang-css.js"></script>
    <!--[if lt IE 9]>
      <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
    <link type="text/css" rel="stylesheet" href="styles/prettify.css">
    <link type="text/css" rel="stylesheet" href="styles/jsdoc.css">
    <script src="scripts/nav.js" defer></script>
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
</head>
<body>

<input type="checkbox" id="nav-trigger" class="nav-trigger" />
<label for="nav-trigger" class="navicon-button x">
  <div class="navicon"></div>
</label>

<label for="nav-trigger" class="overlay"></label>

<nav >
    
    <h2><a href="index.html">Home</a></h2><h3>Classes</h3><ul><li><a href="Fields.html">Fields</a><ul class='methods'><li data-type='method'><a href="Fields.html#.boolean">boolean</a></li><li data-type='method'><a href="Fields.html#.choice">choice</a></li><li data-type='method'><a href="Fields.html#.model">model</a></li><li data-type='method'><a href="Fields.html#.number">number</a></li><li data-type='method'><a href="Fields.html#.string">string</a></li></ul></li><li><a href="FileSystemStore.html">FileSystemStore</a><ul class='methods'><li data-type='method'><a href="FileSystemStore.html#deleteRecord">deleteRecord</a></li><li data-type='method'><a href="FileSystemStore.html#loadRecord">loadRecord</a></li><li data-type='method'><a href="FileSystemStore.html#loadSchema">loadSchema</a></li><li data-type='method'><a href="FileSystemStore.html#ready">ready</a></li><li data-type='method'><a href="FileSystemStore.html#saveMigration">saveMigration</a></li><li data-type='method'><a href="FileSystemStore.html#saveRecord">saveRecord</a></li><li data-type='method'><a href="FileSystemStore.html#saveSchema">saveSchema</a></li></ul></li><li><a href="Model.html">Model</a><ul class='methods'><li data-type='method'><a href="Model.html#.create">create</a></li><li data-type='method'><a href="Model.html#.from">from</a></li><li data-type='method'><a href="Model.html#.load">load</a></li><li data-type='method'><a href="Model.html#delete">delete</a></li><li data-type='method'><a href="Model.html#get">get</a></li><li data-type='method'><a href="Model.html#reset">reset</a></li><li data-type='method'><a href="Model.html#save">save</a></li><li data-type='method'><a href="Model.html#set">set</a></li><li data-type='method'><a href="Model.html#toForm">toForm</a></li><li data-type='method'><a href="Model.html#toHTMLForm">toHTMLForm</a></li><li data-type='method'><a href="Model.html#toHTMLTable">toHTMLTable</a></li><li data-type='method'><a href="Model.html#toHTMLTableRows">toHTMLTableRows</a></li><li data-type='method'><a href="Model.html#toString">toString</a></li><li data-type='method'><a href="Model.html#toTable">toTable</a></li><li data-type='method'><a href="Model.html#toTableRows">toTableRows</a></li><li data-type='method'><a href="Model.html#updateFromSubmission">updateFromSubmission</a></li><li data-type='method'><a href="Model.html#valueOf">valueOf</a></li></ul></li><li><a href="Models.html">Models</a><ul class='methods'><li data-type='method'><a href="Models.html#.create">create</a></li><li data-type='method'><a href="Models.html#.deleteModel">deleteModel</a></li><li data-type='method'><a href="Models.html#.loadModel">loadModel</a></li><li data-type='method'><a href="Models.html#.register">register</a></li><li data-type='method'><a href="Models.html#.resetRegistrations">resetRegistrations</a></li><li data-type='method'><a href="Models.html#.saveModel">saveModel</a></li><li data-type='method'><a href="Models.html#.setStore">setStore</a></li><li data-type='method'><a href="Models.html#.useDefaultStore">useDefaultStore</a></li></ul></li><li><a href="ModelStore.html">ModelStore</a><ul class='methods'><li data-type='method'><a href="ModelStore.html#deleteRecord">deleteRecord</a></li><li data-type='method'><a href="ModelStore.html#loadRecord">loadRecord</a></li><li data-type='method'><a href="ModelStore.html#loadSchema">loadSchema</a></li><li data-type='method'><a href="ModelStore.html#ready">ready</a></li><li data-type='method'><a href="ModelStore.html#saveMigration">saveMigration</a></li><li data-type='method'><a href="ModelStore.html#saveRecord">saveRecord</a></li><li data-type='method'><a href="ModelStore.html#saveSchema">saveSchema</a></li></ul></li></ul><h3>Namespaces</h3><ul><li><a href="conforms.html">conforms</a><ul class='methods'><li data-type='method'><a href="conforms.html#.conforms">conforms</a></li></ul></li><li><a href="diff.html">diff</a><ul class='methods'><li data-type='method'><a href="diff.html#.apply">apply</a></li><li data-type='method'><a href="diff.html#.applyDiff">applyDiff</a></li><li data-type='method'><a href="diff.html#.create">create</a></li><li data-type='method'><a href="diff.html#.createDiff">createDiff</a></li><li data-type='method'><a href="diff.html#.makeChangeHandler">makeChangeHandler</a></li><li data-type='method'><a href="diff.html#.reverse">reverse</a></li><li data-type='method'><a href="diff.html#.reverseDiff">reverseDiff</a></li></ul></li><li><a href="equals.html">equals</a><ul class='methods'><li data-type='method'><a href="equals.html#.equals">equals</a></li></ul></li><li><a href="Errors.html">Errors</a></li><li><a href="html.html">html</a></li><li><a href="schema.html">schema</a><ul class='methods'><li data-type='method'><a href="schema.html#.createDefault">createDefault</a></li><li data-type='method'><a href="schema.html#.createValidator">createValidator</a></li><li data-type='method'><a href="schema.html#.getModelSet">getModelSet</a></li><li data-type='method'><a href="schema.html#.getRecordNameFor">getRecordNameFor</a></li><li data-type='method'><a href="schema.html#.linkSchema">linkSchema</a></li><li data-type='method'><a href="schema.html#.migrate">migrate</a></li><li data-type='method'><a href="schema.html#.migrate%255E2">migrate^2</a></li><li data-type='method'><a href="schema.html#.unlinkSchema">unlinkSchema</a></li><li data-type='method'><a href="schema.html#.validate">validate</a></li></ul></li><li><a href="tree.html">tree</a></li><li><a href="utils.html">utils</a><ul class='methods'><li data-type='method'><a href="utils.html#.sortedObjectKeys">sortedObjectKeys</a></li></ul></li></ul>
</nav>

<div id="main">
    

    



    


    <section class="package">
        <h3> </h3>		
    </section>









    



    <section class="readme usertext">
        <article><h1>Documentation for this library</h1>
<h2>Defining models</h2>
<p>In order to use models for data, the library needs you to define classes that extend <a href="Model.html">Model</a>, which can then be used to wrap data.</p>
<h3>Model class definitions</h3>
<p>The simplest, valid Model extension is one that declares all its fields, and nothing else:</p>
<pre class="prettyprint source lang-javascript"><code>class YourModel extends Model {
  fieldname1 = Fields.fieldType(...);
  fieldname2 = Fields.fieldType(...);
  ...
}
</code></pre>
<p>However, it's generally a better idea to also specify a <code>__meta</code> property.</p>
<pre class="prettyprint source lang-javascript"><code>class YourModel extends Model {
  __meta = {
    ...
  }

  fieldname1 = Fields.fieldType(...);
  fieldname2 = Fields.fieldType(...);
  ...
}
</code></pre>
<h3>Field types and options</h3>
<p>The <a href="Fields.html">Fields</a> class defines several field types that you can use to build out your models.</p>
<ul>
<li><code>boolean(options?)</code>, for true/false values</li>
<li><code>number(options?)</code>, for numerical values</li>
<li><code>string(options?)</code>, for string data</li>
<li><code>choice(values[], options)</code>, for values that can only be one of a predefined list of values.</li>
<li><code>model(modelClass, options)</code>, for submodels (e.g. if it's an object in plain data, it's just another model).</li>
</ul>
<p>Also note that arrays of values (e.g. a field called <code>photos</code> being an array of <code>Photo</code> submodels) are not a separate field type, instead these simply rely on you passing in the <code>array: true</code> property as part of the field options.</p>
<pre class="prettyprint source lang-javascript"><code>class User extends Model {
  photos = Fields.model(Photo, { array: true });
}

class Photo extends Model {
  filename = Fields.string({ validate: ... });
  width = Fields.number(...);
  height = Fields.number(...);
  ...
}
</code></pre>
<p>The full list of options is:</p>
<ul>
<li><code>required</code>: a boolean value that determines whether the field must always have a value</li>
<li><code>default</code>: a default value to use when the field has not been explicitly assigned</li>
<li><code>choices</code>: an array of possible values that this field may take</li>
<li><code>configurable</code>: a boolean value that determines whether this field may be user-updated (i.e. through form submission handling rather than in code)</li>
<li><code>debug</code>: a boolean value that regulates debug behaviour as defined in the library code.</li>
<li><code>validate</code>: a function for performing more elaborate validation than basic type validation can offer.</li>
</ul>
<h3>Custom validation</h3>
<p>The <code>validate</code> property takes a function that takes the to-validate value as input argument, and must fail in one of two ways if the value is invalid:</p>
<ul>
<li>return <code>false</code>, or</li>
<li>throw an <code>Error</code> object.</li>
</ul>
<p>The first is for &quot;simple failure&quot;, where the validation simply fails without any details:</p>
<pre class="prettyprint source lang-javascript"><code>legalAge = Fields.number({
  validate: (value) => value >= 18,
});
</code></pre>
<p>The second is for when more elaborate details are required.</p>
<pre class="prettyprint source lang-javascript"><code>avatar = Fields.string({
  validate: function (value) {
    const errCode = checkBase64Image(value);
    if (errCode !== undefined) {
      throw new Error(
        `avatar was not a valid base64-encoded image (error code: ${errCode}).`
      );
    }
  },
});
</code></pre>
<h2>Constructing models</h2>
<p>There are two ways to create model instances (three, if we include loading from a data store):</p>
<ul>
<li><code>Model.create(Model.ALLOW_INCOMPLETE?)</code>, where <code>Model</code> is your model class</li>
<li><code>Model.from(data, Model.ALLOW_INCOMPLETE?)</code>, where <code>Model</code> is your model class, and <code>data</code> is a required object with one or more values to be used to bootstrap the model instance.</li>
</ul>
<p>The <code>create</code> function builds a new model instance, whereas the <code>from</code> function builds a new model from preexisting data. Both functions can take the <code>ALLOW_INCOMPLETE</code> static symbol that is used by the library to determine whether or not incompletely model creation is allowed. If omitted, trying to create a model without specifying required fields will throw a <a href="Errors.html#.RequiredFieldsMissing">Errors.RequiredFieldsMissing</a> error.</p>
<p>Also note that in addition to plain JS objects, the <code>.from()</code> function also allows for key-pathed objects. That is, while it accepts standard objects like this:</p>
<pre class="prettyprint source lang-javascript"><code>{
  key1: {
    subkey: {
      fieldname: value
    },
    keyfield: value
  },
  key2: {
    something: value
  },
}
</code></pre>
<p>It also allows data to be specified using a &quot;flat&quot; object with value paths encoded as dot-separated key paths:</p>
<pre class="prettyprint source lang-javascript"><code>{
  &quot;key1.subkey.fieldname&quot;: value,
  &quot;key1.keyfield&quot;: value,
  &quot;key2.something&quot;: value,
}
</code></pre>
<p>This is especially useful when dealing with flat data delivery mechanisms such as form submissions or flat-record storage back ends.</p>
<h3>Permissive <code>create</code></h3>
<pre class="prettyprint source lang-javascript"><code>const config = Config.create(Config.ALLOW_INCOMPLETE);
</code></pre>
<h3>Strict <code>create</code></h3>
<pre class="prettyprint source lang-javascript"><code>import { Errors } from &quot;use-models-for-data&quot;;
const { RequiredFieldsMissing } = Errors;

try {
  const user = User.create();
} catch (e) {
  if (e instanceof RequiredFieldsMissing) {
    // this is unexpected, but a known possible failure state.
    console.error(e);
  } else if (...) {
    ...
  }
}
</code></pre>
<h3>Permissive <code>from</code></h3>
<pre class="prettyprint source lang-javascript"><code>const user = User.from(
  {
    name: `Tester McTesting`,
  },
  User.ALLOW_INCOMPLETE
);
</code></pre>
<h3>Strict <code>from</code></h3>
<pre class="prettyprint source lang-javascript"><code>try {
  const user = User.from({
    name: `Tester McTesting`,
  });
} else {
  // see &quot;strict create&quot;, above.
}
</code></pre>
<h2>Using models</h2>
<p>With your data encoded as a model instance, you can now treat it like any other plain JS object, referencing and assigning values as usual. However, assignments may throw, as <em>all assignments</em> are locked behind validation, including entire subtree assignments.</p>
<h3>Set/get values with automatic validation</h3>
<p>Everything should work exactly the same as if your model was a plain object:</p>
<pre class="prettyprint source lang-javascript"><code>import Errors from &quot;use-models-for-data&quot;;
const { InvalidAssignment } = Errors;

class User extends Model {
  name = Fields.string({ required: true });
  password = Fields.string({ required: true, validate: ... });
}

const user = User.from({ name: ..., password: ... });

try {
  user.name = `A new name`;
  user.password = `A new password`;
} catch (e) {
  if (e instanceof InvalidAssignment) {
    console.error(e);
  } else if (...) {
    ...
  }
}
</code></pre>
<h3>Set/get subtrees with automatic validation</h3>
<p>Even when setting entire subtrees, things should still work as expected:</p>
<pre class="prettyprint source lang-javascript"><code>import Errors from &quot;use-models-for-data&quot;;
const { InvalidAssignment } = Errors;

class ComplexModel extends Model {
  /*
   Some class that models {
     key1: {
       subkey: {
         fieldname: value
       },
       keyfield: value
     },
     key2: {
       something: value
     }
   }
  */
}

const instance = ComplexModel.create();

try {
  instance.key1 = {
    subkey: {
      fieldname: &quot;test&quot;,
    },
    keyfield: 1234,
  };
} catch (e) {
  if (e instanceof InvalidAssignment) {
    console.error(e);
  } else if (...) {
    ...
  }
}
</code></pre>
<h3>Set/get with keypath names</h3>
<p>In addition to getting and setting properties like you would for any JS object, models also support <code>.get(key)</code> and <code>.set(key, value)</code>, for getting/setting nested properties using keys with <code>.</code> delimiters:</p>
<pre class="prettyprint source lang-javascript"><code>const complexInstance = ComplexModel.from(...);
let fieldValue = complexInstance.get(`key1.subkey.fieldname`);
fieldValue = `${fieldValue}-plus`;
complexInstance.set(`key1.subkey.fieldname`, fieldValue);
</code></pre>
<h3>Converting to formatted JSON (with defaults omitted) - <code>.toString()</code></h3>
<p>Any model instance can be turned into JSON (with sorted keys at all depths) by using its <code>.toString()</code> function. However, because model instances are backed by models, this JSON will not include any default values, only encoding real values. As such, the following model:</p>
<pre class="prettyprint source lang-javascript"><code>class User extends Model {
  name = Fields.string({ required: true });
  password = Fields.string({ required: true, validate: ... });
  postCount = Fields.number({ default: 0 })
  rewards = Fields.number({ default: 0 })
  level = Fields.number({ default: 1 })
}
</code></pre>
<p>Will turn into a JSON object with only a name and password using <code>.toString()</code>:</p>
<pre class="prettyprint source lang-javascript"><code>const user = User.create({ name: &quot;Tester McTesting&quot;, password: &quot;abcdef&quot; });
user.level = 2;

console.log(user.toString());
/*
  {
    &quot;level&quot;: 2,
    &quot;name&quot;: &quot;Tester McTesting&quot;,
    &quot;password&quot;: &quot;abcdef&quot;
  }
*/
</code></pre>
<h3>Converting to fully qualified, plain JS object - <code>.valueOf()</code></h3>
<p>To generate a fully qualified object (e.g. when needing to send the model off to something that does <em>not</em> use models for data) the <code>.valueOf()</code> function can be used to turn any model instance into a plain JS object. If you've written your code right, you should never need to use this function. But if you <em>do</em> need it, it's there.</p>
<p>Using the above <code>User</code> model:</p>
<pre class="prettyprint source lang-javascript"><code>const user = User.create({ name: &quot;Tester McTesting&quot;, password: &quot;abcdef&quot; });
const unsafe = user.valueOf();
console.log(JSON.stringify(unsafe));
/*
  {
    &quot;name&quot;: &quot;Tester McTesting&quot;,
    &quot;password&quot;: &quot;abcdef&quot;,
    &quot;postCount&quot;: 0,
    &quot;rewards&quot;: 0,
    &quot;level&quot;: 2
  }
*/
</code></pre>
<h3>(Partially) resetting model instances</h3>
<p>Sometimes it's necessary to not just &quot;set some values&quot; but also &quot;unset previously set values&quot;. Rather than having to write the following code:</p>
<pre class="prettyprint source lang-javascript"><code>const user1 = User.from({ ... });

// ...

const { name, password, level } = user1;
const user2 = User.from({ name, password, level});
</code></pre>
<p>You can use the <code>.reset()</code> function, with an optional object for reassigning some (or all) fields some new data, without having to declare new variables:</p>
<pre class="prettyprint source lang-javascript"><code>const user = User.from({ ... });

// ...

const { name, password, level } = user;
user.reset({ name, password, level});
</code></pre>
<h2>Using models for/in the browser</h2>
<p>Models wouldn't be very useful if you could only use them server side: you can use models for data anywhere that you can use (modern) Javascript.</p>
<h3>Import/bundling your model definition</h3>
<p>When writing client-side JS, all you need to do is import your classes as usually, and let your bundler (for modern JS) take care of the rest. This way your client and server will be &quot;speaking the same models&quot; no matter how much you update them.</p>
<h3>Tree mapping your model</h3>
<h3>Forms for editing</h3>
<p>While updating models using code makes a ton of sense server-side, when we're using a browser you probably want to offer users a way to work with models too, for instance, in order to update their preferences, edit a post, etc. You can of course roll your own code for the just the bits that you need, but if you just want &quot;automatic full-model editing forms&quot; then you're in luck because that's something this library also offers.</p>
<p>All element-building is based on walking your model as a data tree, turning leaves and non-leaves into meaningful data, with an options object to control things like pre/post code, value update handling, etc. See the <a href="#custom-trees">custom trees</a> section below for the full description of this process.</p>
<h4>HTML form/table</h4>
<p>Since the browser mostly cares about HTML code, models have code in place to automatically generate <code>&lt;form&gt;</code> and <code>&lt;table&gt;</code> elements for working with model data using standard HTML form fields, in addition to being able to generate a &quot;bare&quot; set of <code>&lt;tr&gt;</code> table rows for slotting into your own HTML template.</p>
<ul>
<li><code>toHTMLForm(options?)</code>: generates a <code>&lt;form&gt;</code> element with nested data wrapped as <code>&lt;fieldset&gt;</code> elements.</li>
<li><code>toHTMLTable(options?)</code>: generates a <code>&lt;table&gt;</code> element as a flat representation of your model data.</li>
<li><code>toHTMLTableRows(options?)</code>: only generates the set of <code>&lt;tr&gt;</code>, with each row corresponding to one leaf of your model's data tree.</li>
</ul>
<p>Using these is about as close to no work as possible:</p>
<pre class="prettyprint source lang-javascript"><code>import { User } from &quot;../src/models/user.js&quot;;

// ...

function generateUserForm(user) {
  document.querySelector(`#modal .form-panel`)?.innerHTML = user.toHTMLForm();
}

// ...

editButton.addEventListener(`click`, evt => generateUserForm(evt));
</code></pre>
<p>Of course, while models can perform data validation, they don't automatically test whether data is web-safe, so as always: when working with user data, <code>innerHTML</code> is rarely safe, and you may want to use a sanitizer to verify on that HTML.</p>
<p>For a more secure version, generating the content using the generic <a href="#custom-trees">custom tree</a> approach will generally be a better idea.</p>
<h4>(P)React form/table</h4>
<pre class="prettyprint source lang-jsx"><code>import { Component, createElement } from &quot;(p)react&quot;;
import { User as UserModel } from &quot;./src/models/user.js&quot;;

class UserProfile extends Component {
  constructor(props) {
    super(props);
    this.user = UserModel.from(this.props.userData);
  }

  render() {
    return (
      &lt;>
        &lt;h2>Edit profile&lt;/h2>
        {this.buildProfileForm()}
      &lt;/>
    );
  }

  buildProfileForm() {
    const tableOptions = {
      create: createElement,
      inputHandler: {
        onInput: (evt) => {
          const { name, type, checked, value } = evt.target;
          const newValue = type === `checkbox` ? checked : value;
          try {
            // As form elements use keypaths for input names,
            // we use the .set() function to assign the updated
            // value to our model.
            this.user.set(name, newValue);
          } catch (e) {
            // Warn the user about invalid data, either
            // via an effect, a state update, a modal,
            // etc.
          }
        },
      },
    };

    return (
      &lt;table ref={(e) => (this.profileTable = e)}>
        {this.user.toTableTree(tableOptions)}
      &lt;/table>
    );
  }
}
</code></pre>
<h4>Custom trees</h4>
<p>If you're using a tech stack that isn't explicitly covered by this library, you can relatively easily write your own &quot;tree serializer&quot; using the same approach as used when using (P)React, where you specify the key elements required for the tree conversion, and the code does the rest. This is done by passing in an options object to the <code>.toForm()</code>, <code>.toTable()</code>, or <code>.toTableRows()</code> function, which can be giving the following properties:</p>
<ul>
<li><code>create: function(tag, options)</code>: a function that turns a tag-and-options tuple into whatever nestable data structure is required for your tech stack to work.</li>
<li><code>footer</code>: any kind of content that you need added to the end (only applies to <code>form</code> and <code>table</code> generation),</li>
<li><code>label: function(key)</code>: a function that turns a field value's key path into something useful (like turning <code>key1.fieldvalue</code> into <code>Key1 fieldvalue</code>).</li>
<li><code>skipDebug</code>: boolean, omits all model fields marked as <code>debug</code> from the resulting data structure.</li>
<li><code>inputHandler</code>: an object that gets dereferenced when processing all child nodes, adding its content as child property for input handling. For example, for (P)React this would be <code>{ onInput: evt =&gt; { ... }}</code>, so that elements end up being some <code>&lt;InputElement onInput={evt =&gt; ... }/&gt;</code>.</li>
</ul>
<p>In addition to this, you can tack any additional properties you need for your data structures. For example, (P)React triggers an <code>onSubmit</code> when a form is submitted, and so adding an <code>onSubmit</code> property to the options object with a handling function will automatically cause that to kick in.</p>
<h2>Using a data store</h2>
<p>Using models to ensure your data is always valid also requires knowing that your models themselves are synced between the various parts of your code, as well as between your storage backend(s) and your code. As such, this library lets you basically use any backend you like, as long as you can write a <a href="ModelStore.html">ModelStore</a> for it.</p>
<p>The library comes with a single ModelStore implementation predefined, the <a href="FileSystemStore.html">FileSystemStore</a>, which uses your local filesystem as a storage backend.</p>
<h3>Using a <a href="ModelStore.html">ModelStore</a></h3>
<ul>
<li>
<p>ready()</p>
</li>
<li>
<p>async loadRecord(schema, recordName)</p>
</li>
<li>
<p>async saveRecord(schema, instance, recordName)</p>
</li>
<li>
<p>async deleteRecord(schema, recordName)</p>
</li>
<li>
<p>async loadSchema(schema)</p>
</li>
<li>
<p>async saveSchema(Model) // <strong>THIS SHOULD TAKE A SCHEMA ARGUMENT, NOT A MODEL</strong></p>
</li>
<li>
<p>async saveMigration(schema1, schema2, migration)</p>
</li>
</ul>
<h3><code>await</code>ing all <code>Model.create()</code> / <code>Model.from()</code> calls</h3>
<p>When using a model store, all schema and record operations are necessarily asynchronous, and so one thing that changes is that <code>Model.create</code> and <code>Model.from</code> will no longer work synchronously, requiring you either <code>await</code> them, or use <code>.then(instance =&gt; ...)</code> chaining.</p>
<h3>saving models to the store</h3>
<p>...</p>
<h3>loading models from the store</h3>
<p>...</p>
<h3>deleting models from the store</h3>
<p>...</p>
<h3>updating your model definitions</h3>
<p>...</p>
<h4>schema change detection</h4>
<p>...</p>
<h4>data migrations</h4>
<p>...</p>
<h2>utilities</h2>
<p>...</p>
<h3>(coercing) deep <code>equals()</code></h3>
<p>...</p>
<h3>JS object diffing</h3>
<p>...</p></article>
    </section>






    
    
</div>

<br class="clear">

<footer>
    Documentation generated by <a href="https://github.com/jsdoc3/jsdoc">JSDoc 3.6.7</a> on Tue Oct 26 2021 09:15:42 GMT-0700 (Pacific Daylight Time) using the <a href="https://github.com/clenemt/docdash">docdash</a> theme.
</footer>

<script>prettyPrint();</script>
<script src="scripts/polyfill.js"></script>
<script src="scripts/linenumber.js"></script>



</body>
</html>