<!DOCTYPE html>
<html lang="en">
<head>
    
    <meta charset="utf-8">
    <title>models/models.js - Documentation</title>
    
    
    <script src="scripts/prettify/prettify.js"></script>
    <script src="scripts/prettify/lang-css.js"></script>
    <!--[if lt IE 9]>
      <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
    <link type="text/css" rel="stylesheet" href="styles/prettify.css">
    <link type="text/css" rel="stylesheet" href="styles/jsdoc.css">
    <script src="scripts/nav.js" defer></script>
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
</head>
<body>

<input type="checkbox" id="nav-trigger" class="nav-trigger" />
<label for="nav-trigger" class="navicon-button x">
  <div class="navicon"></div>
</label>

<label for="nav-trigger" class="overlay"></label>

<nav >
    
    <h2><a href="index.html">Home</a></h2><h3>Classes</h3><ul><li><a href="Fields.html">Fields</a><ul class='methods'><li data-type='method'><a href="Fields.html#.boolean">boolean</a></li><li data-type='method'><a href="Fields.html#.choice">choice</a></li><li data-type='method'><a href="Fields.html#.model">model</a></li><li data-type='method'><a href="Fields.html#.number">number</a></li><li data-type='method'><a href="Fields.html#.string">string</a></li></ul></li><li><a href="FileSystemStore.html">FileSystemStore</a><ul class='methods'><li data-type='method'><a href="FileSystemStore.html#deleteRecord">deleteRecord</a></li><li data-type='method'><a href="FileSystemStore.html#loadRecord">loadRecord</a></li><li data-type='method'><a href="FileSystemStore.html#loadSchema">loadSchema</a></li><li data-type='method'><a href="FileSystemStore.html#ready">ready</a></li><li data-type='method'><a href="FileSystemStore.html#saveMigration">saveMigration</a></li><li data-type='method'><a href="FileSystemStore.html#saveRecord">saveRecord</a></li><li data-type='method'><a href="FileSystemStore.html#saveSchema">saveSchema</a></li></ul></li><li><a href="Model.html">Model</a><ul class='methods'><li data-type='method'><a href="Model.html#.create">create</a></li><li data-type='method'><a href="Model.html#.load">load</a></li><li data-type='method'><a href="Model.html#delete">delete</a></li><li data-type='method'><a href="Model.html#get">get</a></li><li data-type='method'><a href="Model.html#reset">reset</a></li><li data-type='method'><a href="Model.html#save">save</a></li><li data-type='method'><a href="Model.html#set">set</a></li><li data-type='method'><a href="Model.html#toForm">toForm</a></li><li data-type='method'><a href="Model.html#toHTMLForm">toHTMLForm</a></li><li data-type='method'><a href="Model.html#toHTMLTable">toHTMLTable</a></li><li data-type='method'><a href="Model.html#toHTMLTableRows">toHTMLTableRows</a></li><li data-type='method'><a href="Model.html#toString">toString</a></li><li data-type='method'><a href="Model.html#toTable">toTable</a></li><li data-type='method'><a href="Model.html#toTableRows">toTableRows</a></li><li data-type='method'><a href="Model.html#updateFromSubmission">updateFromSubmission</a></li><li data-type='method'><a href="Model.html#valueOf">valueOf</a></li></ul></li><li><a href="Models.html">Models</a><ul class='methods'><li data-type='method'><a href="Models.html#.create">create</a></li><li data-type='method'><a href="Models.html#.deleteModel">deleteModel</a></li><li data-type='method'><a href="Models.html#.loadModel">loadModel</a></li><li data-type='method'><a href="Models.html#.register">register</a></li><li data-type='method'><a href="Models.html#.resetRegistrations">resetRegistrations</a></li><li data-type='method'><a href="Models.html#.saveModel">saveModel</a></li><li data-type='method'><a href="Models.html#.setStore">setStore</a></li><li data-type='method'><a href="Models.html#.useDefaultStore">useDefaultStore</a></li></ul></li><li><a href="ModelStore.html">ModelStore</a><ul class='methods'><li data-type='method'><a href="ModelStore.html#deleteRecord">deleteRecord</a></li><li data-type='method'><a href="ModelStore.html#loadRecord">loadRecord</a></li><li data-type='method'><a href="ModelStore.html#loadSchema">loadSchema</a></li><li data-type='method'><a href="ModelStore.html#ready">ready</a></li><li data-type='method'><a href="ModelStore.html#saveMigration">saveMigration</a></li><li data-type='method'><a href="ModelStore.html#saveRecord">saveRecord</a></li><li data-type='method'><a href="ModelStore.html#saveSchema">saveSchema</a></li></ul></li></ul><h3>Namespaces</h3><ul><li><a href="conforms.html">conforms</a><ul class='methods'><li data-type='method'><a href="conforms.html#.conforms">conforms</a></li></ul></li><li><a href="diff.html">diff</a><ul class='methods'><li data-type='method'><a href="diff.html#.apply">apply</a></li><li data-type='method'><a href="diff.html#.applyDiff">applyDiff</a></li><li data-type='method'><a href="diff.html#.create">create</a></li><li data-type='method'><a href="diff.html#.createDiff">createDiff</a></li><li data-type='method'><a href="diff.html#.makeChangeHandler">makeChangeHandler</a></li><li data-type='method'><a href="diff.html#.reverse">reverse</a></li><li data-type='method'><a href="diff.html#.reverseDiff">reverseDiff</a></li></ul></li><li><a href="equals.html">equals</a><ul class='methods'><li data-type='method'><a href="equals.html#.equals">equals</a></li></ul></li><li><a href="Errors.html">Errors</a></li><li><a href="html.html">html</a></li><li><a href="schema.html">schema</a><ul class='methods'><li data-type='method'><a href="schema.html#.createDefault">createDefault</a></li><li data-type='method'><a href="schema.html#.createValidator">createValidator</a></li><li data-type='method'><a href="schema.html#.getModelSet">getModelSet</a></li><li data-type='method'><a href="schema.html#.getRecordNameFor">getRecordNameFor</a></li><li data-type='method'><a href="schema.html#.linkSchema">linkSchema</a></li><li data-type='method'><a href="schema.html#.migrate">migrate</a></li><li data-type='method'><a href="schema.html#.migrate%255E2">migrate^2</a></li><li data-type='method'><a href="schema.html#.unlinkSchema">unlinkSchema</a></li><li data-type='method'><a href="schema.html#.validate">validate</a></li></ul></li><li><a href="tree.html">tree</a></li><li><a href="utils.html">utils</a><ul class='methods'><li data-type='method'><a href="utils.html#.sortedObjectKeys">sortedObjectKeys</a></li></ul></li></ul>
</nav>

<div id="main">
    
    <h1 class="page-title">models/models.js</h1>
    

    



    
    <section>
        <article>
            <pre class="prettyprint source linenums"><code>import {
  NoStoreFound,
  StoreNotReady,
  AssignmentMustBeArray,
  InvalidAssignment,
  RequiredFieldsMissing,
} from "../errors.js";
import { copyFromSource, setDataFrom } from "./utils.js";
import { registry } from "./model-registry.js";
import { Model } from "./model.js";
import * as basicSchema from "../schema/basic-js-schema.js";
import { buildValidatingArray } from "./build-validating-array.js";
import * as fields from "./fields.js";
const { Fields } = fields;

/**
 * This is, effectively, the Model manager and factory.
 * @hideconstructor
 */
export class Models {
  /**
   * Used by save/load functions.
   * @param {*} store
   * @returns the static Models class, for call chaining purposes.
   */
  static setStore(store) {
    this.store = store;
    registry.setStore(store);
    return this;
  }

  /**
   * Async dynamic import, so that we don't end up bundling `fs` related
   * file storage during a client-bundling operation.
   * @param {*} path
   */
  static async useDefaultStore(path) {
    const { FileSystemStore } = await import("./store/filesystem-store.js");
    const store = new FileSystemStore(path);
    Models.setStore(store);
  }

  /**
   * Make sure that the store is ready for load/save operations.
   * @ignore
   */
  static verifyStore() {
    if (!this.store) {
      throw new NoStoreFound();
    }
    if (!this.store.ready()) {
      throw new StoreNotReady();
    }
  }

  /**
   * &lt;p>register all model classes so that we know whether or not
   * they still match their previously stored schema. If not,
   * this will throw and you should run a schema migration before
   * your model-related code will run without errors.&lt;/p>
   *
   * &lt;p>If a backend store is used, this function will run &lt;code>async&lt;/code>,
   * returning a &lt;code>Promise&lt;/code> that can be &lt;code>await&lt;/code>ed,
   * or handled with &lt;code>.then()&lt;/code>&lt;/p>
   *
   * &lt;p>When no backend is used, this function will run synchronously.&lt;/p>
   *
   * @param  {Model[]} models - one or more Model class instances
   * @returns {schema[]} A list of model-associated schemas, mapped per input model
   */
  static register(...models) {
    if (this.store) return this.__registerAsync(...models);
    return this.__registerSync(...models);
  }

  /** @ignore */
  static async __registerAsync(...models) {
    const list = models.slice();
    while (list.length) {
      await registry.recordModelClassAsync(list.shift());
    }
    return models.map((model) => registry.getRegisteredSchema(model.name));
  }

  /** @ignore */
  static __registerSync(...models) {
    return models.map((model) => registry.recordModelClassSync(model));
  }

  /**
   * Forget all registered models
   */
  static resetRegistrations() {
    registry.resetRegistrations();
  }

  /**
   * &lt;p>Create a model instance.&lt;/p>
   *
   * @param {class} Model - The model class to instantiate.
   * @param {object} data - the data with which to bootstrap the new model instantiation.
   * @param {boolean} [allowIncomplete] - True if missing required fields should be allowed, false if not.
   * @returns {Model} an instance of the passed Model class.
   */
  static create(Model, data, allowIncomplete = false) {
    const { name, schema } = Model;

    // if we don't know this model, this will throw.
    registry.getRegisteredSchema(name);

    const instance = new Model(this, Date.now());
    fromSchemaToData(instance);

    // Assign this model's initial data. This will throw if any values do not
    // conform to the model's schema.
    if (data !== undefined) setDataFrom(data, instance);

    // Then, post-validate the instance.
    const result = basicSchema.validate(
      schema,
      instance,
      false,
      allowIncomplete
    );

    if (!result.passed) {
      throw new RequiredFieldsMissing(name, result.errors);
    }

    if (allowIncomplete === Model.ALLOW_INCOMPLETE) {
      Object.defineProperty(instance, `__incomplete`, {
        enumerable: false,
        configurable: true,
        value: true,
      });
    }

    return instance;
  }

  /**
   * Load a model from file (i.e. create a model, then assign values to it based on
   * stored data. We do it in this order to ensure data validation runs)
   * @param {class} Model - The model class to instantiate.
   * @param {String} recordName - The recordName associated with the required instance.
   * @returns {Model} a previously stored instance of the passed Model class.
   */
  static async loadModel(Model, recordName) {
    this.verifyStore();
    const schema = await registry.recordModelClassAsync(Model);

    // Preallocate our data variable, and see if we can assign and use it.
    // Which can fail. In quite a few ways. All of them will throw =)
    let fileData = undefined;

    if (recordName) {
      fileData = await this.store.loadRecord(schema, recordName);
    }

    try {
      return this.create(Model, fileData);
    } catch (e) {
      // And this is where things get interesting: schema mismatch, what do we do?
      console.error(
        `Data for stored record ${recordName} is not schema-conformant.`
      );
      throw e;
    }
  }

  /**
   * Save a model to the back end, but skip any default values
   * because models are bootstrapped with the model's default
   * values before data gets loaded in.
   * @param {Model} instance - A model instance.
   */
  static async saveModel(instance) {
    this.verifyStore();
    const modelName = instance.__proto__.constructor.name;
    const schema = registry.getRegisteredSchema(modelName);
    const recordName = basicSchema.getRecordNameFor(schema, instance);
    await this.store.saveRecord(schema, instance, recordName);
  }

  /**
   * Delete a model from the back end.
   * @param {Model} instance - A model instance.
   */
  static async deleteModel(instance) {
    this.verifyStore();
    const modelName = instance.__proto__.constructor.name;
    const schema = registry.getRegisteredSchema(modelName);
    const recordName = basicSchema.getRecordNameFor(schema, instance);
    await this.store.deleteRecord(schema, recordName);
  }

  // And some convenience "static exports"
  static fields = Fields;
}

/**
 * Rewrite a model from its initial "schema" layout
 * to the actually usable "controlled data" layout.
 * @ignore
 */
export function fromSchemaToData(model) {
  if (model.__converted) return model;

  const props = Object.entries(model);
  props.forEach(([key, definition]) => {
    const array = key !== `__meta` &amp;&amp; definition.__meta.array;
    const { shape } = definition;
    if (shape) {
      definition = shape;
    }

    // we don't need to retain metadata, this is instead
    // kept around in the Models.modelTrees dictionary.
    if (key === `__meta`) {
      delete model.__meta;
    }

    // non-model subtrees
    else if (!!shape || definition.__meta?.name) {
      let schema;

      // If this is a proper model, we should already have its associated
      // schema stored both in the registry and on the model class (set
      // as part of the registry.recordModelClass() code path)
      if (typeof Model !== `undefined` &amp;&amp; definition instanceof Model) {
        schema = definition.__proto__.constructor.schema;
      }

      // If not, treat the definition as the schema.
      else {
        schema = copyFromSource(definition);
      }

      // If this is an array-of-[...], we need a special array that
      // can perform seemless data assignment/extraction.
      if (array) {
        const proxy = buildValidatingArray(schema, definition);
        Object.defineProperty(model, key, {
          configurable: false,
          get: () => proxy,
          set: (data) => {
            if (!(data instanceof Array)) {
              throw new AssignmentMustBeArray(key);
            }
            while (proxy.length > 0) proxy.pop();
            proxy.push(...data);
          },
        });
      }

      // Otherwise, we can set up "simple" get/set logic.
      else {
        Object.defineProperty(model, key, {
          configurable: false,
          get: () => definition,
          set: (data) => {
            const result = basicSchema.validate(schema, data);
            if (result.passed) setDataFrom(data, definition);
            else {
              throw new InvalidAssignment(key, data, result.errors);
            }
          },
        });
      }

      // And then we recurse.
      fromSchemaToData(definition);
    }

    // everything else is a simple (validation-controlled) property
    else setupReferenceHandler(model, key, definition);
  });

  Object.defineProperty(model, `__converted`, {
    configurable: false,
    enumerable: false,
    writable: false,
    value: true,
  });

  return model;
}

/**
 * Set up the property to initially be undefined and non-enumerable.
 * When the property is assigned a value that is not the default,
 * we toggle the field to enumerable so that it "shows up" when
 * using Object.keys/values/entries and JSON serialization.
 *
 * @ignore
 */
export function setupReferenceHandler(model, key, definition) {
  const defaultValue = definition.default;
  let __proxy = defaultValue;

  Object.defineProperty(model, key, {
    configurable: true, // defaults to false, so needs to explicitly be set to true
    enumerable: false, // hide this key for object iteration purposes by default
    get: () => __proxy,
    set: (value) => {
      const result = fields.validate(key, value, definition);
      if (result.passed) {
        __proxy = value;
        // For non default values, include this key when iterating over the object,
        // but default values exclude this key for iteration purposes.
        Object.defineProperty(model, key, {
          enumerable: value !== defaultValue,
        });
      } else {
        throw new InvalidAssignment(key, value, result.errors);
      }
    },
  });
}
</code></pre>
        </article>
    </section>




    
    
</div>

<br class="clear">

<footer>
    Documentation generated by <a href="https://github.com/jsdoc3/jsdoc">JSDoc 3.6.7</a> on Thu Nov 11 2021 18:07:30 GMT-0800 (Pacific Standard Time) using the <a href="https://github.com/clenemt/docdash">docdash</a> theme.
</footer>

<script>prettyPrint();</script>
<script src="scripts/polyfill.js"></script>
<script src="scripts/linenumber.js"></script>



</body>
</html>
