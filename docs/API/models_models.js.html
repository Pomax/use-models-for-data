<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <title>JSDoc: Source: models/models.js</title>

    <script src="scripts/prettify/prettify.js"> </script>
    <script src="scripts/prettify/lang-css.js"> </script>
    <!--[if lt IE 9]>
      <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
    <link type="text/css" rel="stylesheet" href="styles/prettify-tomorrow.css">
    <link type="text/css" rel="stylesheet" href="styles/jsdoc-default.css">
</head>

<body>

<div id="main">

    <h1 class="page-title">Source: models/models.js</h1>

    



    
    <section>
        <article>
            <pre class="prettyprint source linenums"><code>import {
  NoStoreFound,
  AssignmentMustBeArray,
  InvalidAssignment,
  RequiredFieldsMissing,
} from "../errors.js";
import { copyFromSource, setDataFrom } from "./utils.js";
import { registry } from "./model-registry.js";
import { Model } from "./model.js";
import * as basicSchema from "../schema/basic-js-schema.js";
import { buildValidatingArray } from "./build-validating-array.js";
import * as fields from "./fields.js";
const { Fields } = fields;

/**
 * This is, effectively, the Model manager and factory.
 * @hideconstructor
 */
export class Models {
  /**
   * Used by save/load functions.
   * @param {*} store
   * @returns the static Models class, for call chaining purposes.
   */
  static setStore(store) {
    Models.store = store;
    registry.setStore(store);
    return this;
  }

  /**
   * Async dynamic import, so that we don't end up bundling `fs` related
   * file storage during a client-bundling operation.
   * @param {*} path
   */
  static async useDefaultStore(path) {
    const { FileSystemStore } = await import("./store/filesystem-store.js");
    const store = new FileSystemStore(path);
    Models.setStore(store);
  }

  /**
   * Make sure that the store is ready for load/save operations.
   * @ignore
   */
  static verifyStore() {
    if (!Models.store.ready()) {
      throw new NoStoreFound();
    }
  }

  /**
   * register all model classes so that we know whether or not
   * they still match their previously stored schema. If not,
   * this will throw and you should run a schema migration before
   * your model-related code will run without errors.
   * @param  {...Model} models
   */
  static register(...models) {
    models.forEach((Model) => registry.recordModelClass(Model));
  }

  /**
   * Forget all registered models
   */
  static resetRegistrations() {
    registry.resetRegistrations();
  }

  /**
   * Create a model instance, making sure its schema is known.
   * @param {*} Model
   * @param {*} data
   * @param {*} allowIncomplete
   * @returns {Model} an instance of the passed Model class.
   */
  static create(Model, data, allowIncomplete) {
    registry.recordModelClass(Model);

    const { name, schema } = Model;
    const instance = new Model(this, Date.now());
    fromSchemaToData(instance);

    // Assign this model's initial data. This will throw if any values do not
    // conform to the model's schema.
    if (data !== undefined) setDataFrom(data, instance);

    // Then, post-validate the instance.
    const result = basicSchema.validate(
      schema,
      instance,
      false,
      allowIncomplete
    );

    if (!result.passed) {
      throw new RequiredFieldsMissing(name, result.errors);
    }

    if (allowIncomplete === Model.ALLOW_INCOMPLETE) {
      Object.defineProperty(instance, `__incomplete`, {
        enumerable: false,
        configurable: true,
        value: true,
      });
    }

    return instance;
  }

  /**
   * Load a model from file (i.e. create a model, then assign values to it based on
   * stored data. We do it in this order to ensure data validation runs)
   * @param {*} Model
   * @param {*} recordName
   * @returns {Model} a previously stored instance of the passed Model class.
   */
  static async loadModel(Model, recordName) {
    this.verifyStore();
    const schema = registry.recordModelClass(Model);

    // Preallocate our data variable, and see if we can assign and use it.
    // Which can fail. In quite a few ways. All of them will throw =)
    let fileData = undefined;

    if (recordName) {
      fileData = await Models.store.loadRecord(schema, recordName);
    }

    try {
      return this.create(Model, fileData);
    } catch (e) {
      // And this is where things get interesting: schema mismatch, what do we do?
      console.error(
        `Data for stored record ${recordName} is not schema-conformant.`
      );
      throw e;
    }
  }

  /**
   * Save a model to file, but skip any default values because models are
   * bootstrapped with the model's default values before data gets loaded in.
   * @param {*} instance
   */
  static async saveModel(instance) {
    this.verifyStore();
    const modelName = instance.__proto__.constructor.name;
    const schema = registry.getRegisteredSchema(modelName);
    const recordName = basicSchema.getRecordNameFor(schema, instance);
    await Models.store.saveRecord(schema, instance, recordName);
  }

  // And some convenience "static exports"
  static fields = Fields;
}

/**
 * Rewrite a model from its initial "schema" layout
 * to the actually usable "controlled data" layout.
 * @ignore
 */
export function fromSchemaToData(model) {
  if (model.__converted) return model;

  const props = Object.entries(model);
  props.forEach(([key, definition]) => {
    const array = key !== `__meta` &amp;&amp; definition.__meta.array;
    const { shape } = definition;
    if (shape) {
      definition = shape;
    }

    // we don't need to retain metadata, this is instead
    // kept around in the Models.modelTrees dictionary.
    if (key === `__meta`) {
      delete model.__meta;
    }

    // non-model subtrees
    else if (!!shape || definition.__meta?.name) {
      let schema;

      // If this is a proper model, we should already have its associated
      // schema stored both in the registry and on the model class (set
      // as part of the registry.recordModelClass() code path)
      if (definition instanceof Model) {
        schema = definition.__proto__.constructor.schema;
      }

      // If not, treat the definition as the schema.
      else {
        schema = copyFromSource(definition);
      }

      // If this is an array-of-[...], we need a special array that
      // can perform seemless data assignment/extraction.
      if (array) {
        const proxy = buildValidatingArray(schema, definition);
        Object.defineProperty(model, key, {
          configurable: false,
          get: () => proxy,
          set: (data) => {
            if (!(data instanceof Array)) {
              throw new AssignmentMustBeArray(key);
            }
            while (proxy.length > 0) proxy.pop();
            proxy.push(...data);
          },
        });
      }

      // Otherwise, we can set up "simple" get/set logic.
      else {
        Object.defineProperty(model, key, {
          configurable: false,
          get: () => definition,
          set: (data) => {
            const result = basicSchema.validate(schema, data);
            if (result.passed) setDataFrom(data, definition);
            else {
              throw new InvalidAssignment(key, data, result.errors);
            }
          },
        });
      }

      // And then we recurse.
      fromSchemaToData(definition);
    }

    // everything else is a simple (validation-controlled) property
    else setupReferenceHandler(model, key, definition);
  });

  Object.defineProperty(model, `__converted`, {
    configurable: false,
    enumerable: false,
    writable: false,
    value: true,
  });

  return model;
}

/**
 * Set up the property to initially be undefined and non-enumerable.
 * When the property is assigned a value that is not the default,
 * we toggle the field to enumerable so that it "shows up" when
 * using Object.keys/values/entries and JSON serialization.
 *
 * @ignore
 */
export function setupReferenceHandler(model, key, definition) {
  const defaultValue = definition.default;
  let __proxy = defaultValue;

  Object.defineProperty(model, key, {
    configurable: true, // defaults to false, so needs to explicitly be set to true
    enumerable: false, // hide this key for object iteration purposes by default
    get: () => __proxy,
    set: (value) => {
      const result = fields.validate(key, value, definition);
      if (result.passed) {
        __proxy = value;
        // For non default values, include this key when iterating over the object,
        // but default values exclude this key for iteration purposes.
        Object.defineProperty(model, key, {
          enumerable: value !== defaultValue,
        });
      } else {
        throw new InvalidAssignment(key, value, result.errors);
      }
    },
  });
}
</code></pre>
        </article>
    </section>




</div>

<nav>
    <h2><a href="index.html">Home</a></h2><h3>Namespaces</h3><ul><li><a href="conforms.html">conforms</a></li><li><a href="diff.html">diff</a></li><li><a href="equals.html">equals</a></li><li><a href="Errors.html">Errors</a></li><li><a href="html.html">html</a></li><li><a href="schema.html">schema</a></li><li><a href="tree.html">tree</a></li><li><a href="utils.html">utils</a></li></ul><h3>Classes</h3><ul><li><a href="Fields.html">Fields</a></li><li><a href="FileSystemStore.html">FileSystemStore</a></li><li><a href="Model.html">Model</a></li><li><a href="Models.html">Models</a></li><li><a href="ModelStore.html">ModelStore</a></li></ul>
</nav>

<br class="clear">

<footer>
    Documentation generated by <a href="https://github.com/jsdoc/jsdoc">JSDoc 3.6.7</a> on Sun Oct 17 2021 14:28:50 GMT-0700 (Pacific Daylight Time)
</footer>

<script> prettyPrint(); </script>
<script src="scripts/linenumber.js"> </script>
</body>
</html>
