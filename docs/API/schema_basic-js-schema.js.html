<!DOCTYPE html>
<html lang="en">
<head>
    
    <meta charset="utf-8">
    <title>schema/basic-js-schema.js - Documentation</title>
    
    
    <script src="scripts/prettify/prettify.js"></script>
    <script src="scripts/prettify/lang-css.js"></script>
    <!--[if lt IE 9]>
      <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
    <link type="text/css" rel="stylesheet" href="styles/prettify.css">
    <link type="text/css" rel="stylesheet" href="styles/jsdoc.css">
    <script src="scripts/nav.js" defer></script>
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
</head>
<body>

<input type="checkbox" id="nav-trigger" class="nav-trigger" />
<label for="nav-trigger" class="navicon-button x">
  <div class="navicon"></div>
</label>

<label for="nav-trigger" class="overlay"></label>

<nav >
    
    <h2><a href="index.html">Home</a></h2><h3>Classes</h3><ul><li><a href="Fields.html">Fields</a><ul class='methods'><li data-type='method'><a href="Fields.html#.boolean">boolean</a></li><li data-type='method'><a href="Fields.html#.choice">choice</a></li><li data-type='method'><a href="Fields.html#.model">model</a></li><li data-type='method'><a href="Fields.html#.number">number</a></li><li data-type='method'><a href="Fields.html#.string">string</a></li></ul></li><li><a href="FileSystemStore.html">FileSystemStore</a><ul class='methods'><li data-type='method'><a href="FileSystemStore.html#deleteRecord">deleteRecord</a></li><li data-type='method'><a href="FileSystemStore.html#loadRecord">loadRecord</a></li><li data-type='method'><a href="FileSystemStore.html#loadSchema">loadSchema</a></li><li data-type='method'><a href="FileSystemStore.html#ready">ready</a></li><li data-type='method'><a href="FileSystemStore.html#saveMigration">saveMigration</a></li><li data-type='method'><a href="FileSystemStore.html#saveRecord">saveRecord</a></li><li data-type='method'><a href="FileSystemStore.html#saveSchema">saveSchema</a></li></ul></li><li><a href="Model.html">Model</a><ul class='methods'><li data-type='method'><a href="Model.html#.create">create</a></li><li data-type='method'><a href="Model.html#.from">from</a></li><li data-type='method'><a href="Model.html#.load">load</a></li><li data-type='method'><a href="Model.html#delete">delete</a></li><li data-type='method'><a href="Model.html#get">get</a></li><li data-type='method'><a href="Model.html#reset">reset</a></li><li data-type='method'><a href="Model.html#save">save</a></li><li data-type='method'><a href="Model.html#set">set</a></li><li data-type='method'><a href="Model.html#toForm">toForm</a></li><li data-type='method'><a href="Model.html#toHTMLForm">toHTMLForm</a></li><li data-type='method'><a href="Model.html#toHTMLTable">toHTMLTable</a></li><li data-type='method'><a href="Model.html#toHTMLTableRows">toHTMLTableRows</a></li><li data-type='method'><a href="Model.html#toString">toString</a></li><li data-type='method'><a href="Model.html#toTable">toTable</a></li><li data-type='method'><a href="Model.html#toTableRows">toTableRows</a></li><li data-type='method'><a href="Model.html#updateFromSubmission">updateFromSubmission</a></li><li data-type='method'><a href="Model.html#valueOf">valueOf</a></li></ul></li><li><a href="Models.html">Models</a><ul class='methods'><li data-type='method'><a href="Models.html#.create">create</a></li><li data-type='method'><a href="Models.html#.deleteModel">deleteModel</a></li><li data-type='method'><a href="Models.html#.loadModel">loadModel</a></li><li data-type='method'><a href="Models.html#.register">register</a></li><li data-type='method'><a href="Models.html#.resetRegistrations">resetRegistrations</a></li><li data-type='method'><a href="Models.html#.saveModel">saveModel</a></li><li data-type='method'><a href="Models.html#.setStore">setStore</a></li><li data-type='method'><a href="Models.html#.useDefaultStore">useDefaultStore</a></li></ul></li><li><a href="ModelStore.html">ModelStore</a><ul class='methods'><li data-type='method'><a href="ModelStore.html#deleteRecord">deleteRecord</a></li><li data-type='method'><a href="ModelStore.html#loadRecord">loadRecord</a></li><li data-type='method'><a href="ModelStore.html#loadSchema">loadSchema</a></li><li data-type='method'><a href="ModelStore.html#ready">ready</a></li><li data-type='method'><a href="ModelStore.html#saveMigration">saveMigration</a></li><li data-type='method'><a href="ModelStore.html#saveRecord">saveRecord</a></li><li data-type='method'><a href="ModelStore.html#saveSchema">saveSchema</a></li></ul></li></ul><h3>Namespaces</h3><ul><li><a href="conforms.html">conforms</a><ul class='methods'><li data-type='method'><a href="conforms.html#.conforms">conforms</a></li></ul></li><li><a href="diff.html">diff</a><ul class='methods'><li data-type='method'><a href="diff.html#.apply">apply</a></li><li data-type='method'><a href="diff.html#.applyDiff">applyDiff</a></li><li data-type='method'><a href="diff.html#.create">create</a></li><li data-type='method'><a href="diff.html#.createDiff">createDiff</a></li><li data-type='method'><a href="diff.html#.makeChangeHandler">makeChangeHandler</a></li><li data-type='method'><a href="diff.html#.reverse">reverse</a></li><li data-type='method'><a href="diff.html#.reverseDiff">reverseDiff</a></li></ul></li><li><a href="equals.html">equals</a><ul class='methods'><li data-type='method'><a href="equals.html#.equals">equals</a></li></ul></li><li><a href="Errors.html">Errors</a></li><li><a href="html.html">html</a></li><li><a href="schema.html">schema</a><ul class='methods'><li data-type='method'><a href="schema.html#.createDefault">createDefault</a></li><li data-type='method'><a href="schema.html#.createValidator">createValidator</a></li><li data-type='method'><a href="schema.html#.getModelSet">getModelSet</a></li><li data-type='method'><a href="schema.html#.getRecordNameFor">getRecordNameFor</a></li><li data-type='method'><a href="schema.html#.linkSchema">linkSchema</a></li><li data-type='method'><a href="schema.html#.migrate">migrate</a></li><li data-type='method'><a href="schema.html#.migrate%255E2">migrate^2</a></li><li data-type='method'><a href="schema.html#.unlinkSchema">unlinkSchema</a></li><li data-type='method'><a href="schema.html#.validate">validate</a></li></ul></li><li><a href="tree.html">tree</a></li><li><a href="utils.html">utils</a><ul class='methods'><li data-type='method'><a href="utils.html#.sortedObjectKeys">sortedObjectKeys</a></li></ul></li></ul>
</nav>

<div id="main">
    
    <h1 class="page-title">schema/basic-js-schema.js</h1>
    

    



    
    <section>
        <article>
            <pre class="prettyprint source linenums"><code>/**
 * &lt;p>
 * The schema part of using models for data.
 * &lt;/p>
 *
 * @namespace schema
 */
import { MissingRecordNameBinding } from "../errors.js";
import { conforms } from "./conforms.js";
import { fromSchemaToData } from "../models/models.js";
import { createDiff, applyDiff, makeChangeHandler } from "../diff/diff.js";
import { inflate } from "../models/utils.js";

/**
 * Get the string identifier for this schema-conformant data object.
 * @name schema.getRecordNameFor
 * @function
 * @param {*} schema - A schema definition
 * @param {*} instance - A schema-conformant data object
 * @returns {String} the string identifier for this schema-conformant data object.
 */
export function getRecordNameFor(schema, instance) {
  const indicator = schema.__meta.recordname;

  if (!indicator) {
    throw new MissingRecordNameBinding(schema.__proto__.constructor.name);
  }

  // If the recordname is a function, it will yield the record name given an instance.
  if (typeof indicator === `function`) {
    return indicator(instance);
  }

  // Otherwise, it's a keypath. Traverse the instance to find the key whose value should act as record name.
  return indicator.split(`.`).reduce((obj, e) => obj[e], instance);
}

/**
 * Fully quality a schema by linking in all external schema it depends on.
 * @name schema.linkSchema
 * @function
 * @param {*} schemaInstance - A schema instance with sub-schema link information.
 * @param {*} getLatestSchema - A resolver function for finding sub-schema definitions.
 * @returns {schema} The schema instance with all links replaced by fully qualified sub-schema.
 */
export function linkSchema(schemaInstance, getLatestSchema) {
  const { __meta } = schemaInstance;

  // is this a schema'd property?
  if (__meta &amp;&amp; __meta.schema &amp;&amp; __meta.schemaName) {
    const subschema = getLatestSchema(__meta.schemaName, __meta.schema);
    schemaInstance.__meta = subschema.__meta;
    delete subschema.__meta;
    schemaInstance.shape = subschema;
    return;
  }

  // find all fields that we need to recurse through.
  Object.entries(schemaInstance).forEach(([key, value]) => {
    if (key === `__meta`) return;
    const recursionData = value.shape
      ? value.shape
      : value.__meta
      ? value
      : undefined;
    if (recursionData) linkSchema(recursionData, getLatestSchema);
  });
}

/**
 * Decompose a single schema into a set of linked schema, based
 * on the __meta.distinct property of modelfields with a .shape
 *
 * @name schema.unlinkSchema
 * @function
 * @param {*} schema - A fully qualified schema
 * @returns {schema[]} An array consisting of all individual schema found by walking through the passed schema.
 */
export function unlinkSchema(schema) {
  const list = [{ schema, __meta: schema.__meta }];

  (function iterate(s) {
    Object.entries(s).forEach(([key, value]) => {
      const { __meta, shape } = value;
      if (shape) {
        if (__meta?.distinct) {
          list.push({ schema: shape, __meta });
          s[key] = {
            __meta: {
              schema: shape.__proto__.constructor.name,
              schemaName: __meta.name,
            },
          };
        } else {
          iterate(shape);
        }
      }
    });
  })(schema);

  return list;
}

/**
 * Similar to unlinkSchema, without rewriting the parent
 * when a child model is found. Instead, we get a list of
 * all distinct Model classes.
 *
 * @name schema.getModelSet
 * @function
 * @param {Model} Model - A fully qualified {@link Model}.
 * @returns {Model[]} - An array consisting of all individual models found by walking through the passed model.
 * @see schema.unlinkSchema
 */
export function getModelSet(Model) {
  const list = [Model];

  (function iterate(model) {
    const s = new model(getModelSet, Date.now());
    Object.entries(s).forEach(([key, value]) => {
      const { __meta, shape } = value;
      if (shape) {
        //if (__meta?.distinct) {
        list.push(shape.__proto__.constructor);
        //} else {
        iterate(shape.__proto__.constructor);
        //}
      }
    });
  })(Model);

  return list;
}

/**
 * &lt;p>Validate an object against a schema. This function does not return
 * a boolean, but a result object that takes the following form:&lt;/p>
 *
 * &lt;pre>&lt;code>
 *   {
 *     passed: boolean,
 *     warnings: string[],
 *     errors: string[],
 *   }
 * &lt;/code>&lt;/pre>
 *
 * &lt;p>As such, use this function in your own code as:&lt;/p>
 *
 * &lt;pre>&lt;code>
 *   const strict = trueOrFalse;
 *   const allowIncomplete = trueOrFalse;
 *   const result = validate(someSchema, myObject, strict, allowIncomplete);
 *   if (result.passed) {
 *     // all good, although result.warnings may contain strict/incomplete related warnings
 *   } else {
 *     // tap into result.errors to find out why your object is invalid
 *   }
 * &lt;/code>&lt;/pre>
 *
 * &lt;p>Note that the &lt;code>strict&lt;/code> flag determines whether or not
 * to perform coercive validation. If &lt;code>strict=false&lt;/code> and the
 * code does need to perform coercion in order for validation to pass,
 * the object will be updated such that it will now pass strict validation.&lt;/p>
 *
 * @name schema.validate
 * @function
 * @param {schema} schema - The schema that the object should conform to
 * @param {object} object - The object to check conformance for
 * @param {boolean} strict - True if strict type validation is required, false for coercive
 * @param {boolean} allowIncomplete - Do not fail validation if there are fields missing from this object
 * @returns {object} See description above
 */
export function validate(
  schema,
  object,
  strict = true,
  allowIncomplete = false
) {
  inflate(object);
  const results = conforms(schema, object, strict, allowIncomplete);
  results.passed = !!results.conforms;
  return results;
}

/**
 *
 */
/**
 * A convenience function for creating a validator that can be passed
 * around, bound to objects, etc.
 *
 * &lt;pre>&lt;code>
 *   import { schema } from "use-models-for-data";
 *
 *   Object.defineProperty(mySchema, `validate`, {
 *     enumerable: false,
 *     value: schema.createValidator(mySchema, false)
 *   });
 * &lt;/code>&lt;/pre>
 *
 * @name schema.createValidator
 * @function
 * @param {schema} schema - The schema against which to validate data objects.
 * @param {boolean} [strict] - True to perform strict validation, or false to validate with coercion. Defaults to &lt;code>true&lt;/code>.
 * @param {boolean} [allowIncomplete] - True to allow missing required fields. Defaults to &lt;code>false&lt;/code>.
 * @returns {function} a function with the same signature as {@link schema.validate}.
 */
export function createValidator(
  schema,
  strict = true,
  allowIncomplete = false
) {
  return (object) => validate(schema, object, strict, allowIncomplete);
}

/**
 * Create a schema instance with all values initialised to their default values.
 *
 * @name schema.createDefault
 * @function
 * @param {*} schema - The schema to instantiate
 * @returns {object} A schema-conformant object with all properties set to their default values.
 */
export function createDefault(schema) {
  return Object.fromEntries(
    Object.entries(schema)
      .map(([key, value]) => {
        if (key === `__meta`) return false;
        if (value.default !== undefined) return [key, value.default];
        if (value.shape) return [key, createDefault(value.shape)];
      })
      .filter(Boolean)
  );
}

/**
 * Migrate an object from being schema1-conformant to schema2-conformant.
 * @name schema.migrate
 * @function
 * @param {object} object - The object to migrate
 * @param {operations} operations - A sequence of operational transforms (e.g. a "diff").
 * @returns An object that conforms to the updated schema.
 */
/**
 * @name schema.migrate^2
 * @function
 * @param {object} object - The object to migrate
 * @param {schema} schema1 - The "original" schema from which to migrate our object.
 * @param {schema} schema2 - The "current" schema to which we want to migrate our object.
 * @returns An object that conforms to the updated schema.
 */
export function migrate(object, ...args) {
  const len = args.length;
  if (len === 1) {
    const [operations] = args;
    return migrateDirectly(object, operations);
  }
  if (len === 2) {
    const [schema1, schema2] = args;
    return migrateWithSchema(object, schema1, schema2);
  }
}

// fall-through for migrate(object, diff)
function migrateDirectly(object, changeOperations) {
  const changeHandler = makeSchemaChangeHandler();
  applyDiff(changeOperations, object, changeHandler);
}

// fall-through for migrate(object, schema1, schema2)
function migrateWithSchema(object, schema1, schema2) {
  const operations = createDiff(schema1, schema2);
  return migrateDirectly(object, operations);
}

/**
 * This generates a change handler to be used with {@link diff.applySchema}
 * in order to apply diffs between two schema definitions to objects that
 * should conform to those schema definitions.
 *
 * You should never need to invoke this function yourself.
 *
 * @name schema.makeSchemaChangeHandler
 * @function
 * @returns the schema-conformant object diff changeHandler.
 * @ignore
 */
export function makeSchemaChangeHandler() {
  return makeChangeHandler(ignoreKey, filterKeyString, transformValue);
}

/**
 * @name schema.ignoreKey
 * @function
 * @param {*} key - An operational-transform-associated key path
 * @param {*} type - operational transform type (add, update, move, remove)
 * @returns {boolean} True if this key/type tuple should be ignored for diff application purposes.
 * @ignore
 */
function ignoreKey(key, _type) {
  if (key.includes(`__meta`)) return true;
  if (key.includes(`.default`)) return true;
  if (key.includes(`.choices`)) return true;
}

/**
 * @name schema.filterKeyString
 * @function
 * @param {String} key - A key path string for an operational transform operation.
 * @returns {String} A (possibly different) key path string.
 * @ignore
 */
function filterKeyString(key) {
  return key.replaceAll(`.shape`, ``);
}

/**
 * @name schema.transformValue
 * @function
 * @param {String} key - A key path string for an operational transform operation.
 * @param {*} value - Any kind of JS data
 * @returns The key-path associated value after forcing "schema-to-data" conversion (which don't do anything if the value is already plain data)
 * @ignore
 */
function transformValue(key, value) {
  const copied = JSON.parse(JSON.stringify(value));
  const transformed = { [key]: copied };
  fromSchemaToData(transformed);
  return transformed[key];
}
</code></pre>
        </article>
    </section>




    
    
</div>

<br class="clear">

<footer>
    Documentation generated by <a href="https://github.com/jsdoc3/jsdoc">JSDoc 3.6.7</a> on Wed Oct 20 2021 08:58:51 GMT-0700 (Pacific Daylight Time) using the <a href="https://github.com/clenemt/docdash">docdash</a> theme.
</footer>

<script>prettyPrint();</script>
<script src="scripts/polyfill.js"></script>
<script src="scripts/linenumber.js"></script>



</body>
</html>
