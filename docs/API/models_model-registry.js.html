<!DOCTYPE html>
<html lang="en">
<head>
    
    <meta charset="utf-8">
    <title>models/model-registry.js - Documentation</title>
    
    
    <script src="scripts/prettify/prettify.js"></script>
    <script src="scripts/prettify/lang-css.js"></script>
    <!--[if lt IE 9]>
      <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
    <link type="text/css" rel="stylesheet" href="styles/prettify.css">
    <link type="text/css" rel="stylesheet" href="styles/jsdoc.css">
    <script src="scripts/nav.js" defer></script>
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
</head>
<body>

<input type="checkbox" id="nav-trigger" class="nav-trigger" />
<label for="nav-trigger" class="navicon-button x">
  <div class="navicon"></div>
</label>

<label for="nav-trigger" class="overlay"></label>

<nav >
    
    <h2><a href="index.html">Home</a></h2><h3>Classes</h3><ul><li><a href="Fields.html">Fields</a><ul class='methods'><li data-type='method'><a href="Fields.html#.boolean">boolean</a></li><li data-type='method'><a href="Fields.html#.choice">choice</a></li><li data-type='method'><a href="Fields.html#.model">model</a></li><li data-type='method'><a href="Fields.html#.number">number</a></li><li data-type='method'><a href="Fields.html#.string">string</a></li></ul></li><li><a href="FileSystemStore.html">FileSystemStore</a><ul class='methods'><li data-type='method'><a href="FileSystemStore.html#deleteRecord">deleteRecord</a></li><li data-type='method'><a href="FileSystemStore.html#loadRecord">loadRecord</a></li><li data-type='method'><a href="FileSystemStore.html#loadSchema">loadSchema</a></li><li data-type='method'><a href="FileSystemStore.html#ready">ready</a></li><li data-type='method'><a href="FileSystemStore.html#saveMigration">saveMigration</a></li><li data-type='method'><a href="FileSystemStore.html#saveRecord">saveRecord</a></li><li data-type='method'><a href="FileSystemStore.html#saveSchema">saveSchema</a></li></ul></li><li><a href="Model.html">Model</a><ul class='methods'><li data-type='method'><a href="Model.html#.create">create</a></li><li data-type='method'><a href="Model.html#.load">load</a></li><li data-type='method'><a href="Model.html#delete">delete</a></li><li data-type='method'><a href="Model.html#get">get</a></li><li data-type='method'><a href="Model.html#reset">reset</a></li><li data-type='method'><a href="Model.html#save">save</a></li><li data-type='method'><a href="Model.html#set">set</a></li><li data-type='method'><a href="Model.html#toForm">toForm</a></li><li data-type='method'><a href="Model.html#toHTMLForm">toHTMLForm</a></li><li data-type='method'><a href="Model.html#toHTMLTable">toHTMLTable</a></li><li data-type='method'><a href="Model.html#toHTMLTableRows">toHTMLTableRows</a></li><li data-type='method'><a href="Model.html#toString">toString</a></li><li data-type='method'><a href="Model.html#toTable">toTable</a></li><li data-type='method'><a href="Model.html#toTableRows">toTableRows</a></li><li data-type='method'><a href="Model.html#updateFromSubmission">updateFromSubmission</a></li><li data-type='method'><a href="Model.html#valueOf">valueOf</a></li></ul></li><li><a href="Models.html">Models</a><ul class='methods'><li data-type='method'><a href="Models.html#.create">create</a></li><li data-type='method'><a href="Models.html#.deleteModel">deleteModel</a></li><li data-type='method'><a href="Models.html#.loadModel">loadModel</a></li><li data-type='method'><a href="Models.html#.register">register</a></li><li data-type='method'><a href="Models.html#.resetRegistrations">resetRegistrations</a></li><li data-type='method'><a href="Models.html#.saveModel">saveModel</a></li><li data-type='method'><a href="Models.html#.setStore">setStore</a></li><li data-type='method'><a href="Models.html#.useDefaultStore">useDefaultStore</a></li></ul></li><li><a href="ModelStore.html">ModelStore</a><ul class='methods'><li data-type='method'><a href="ModelStore.html#deleteRecord">deleteRecord</a></li><li data-type='method'><a href="ModelStore.html#loadRecord">loadRecord</a></li><li data-type='method'><a href="ModelStore.html#loadSchema">loadSchema</a></li><li data-type='method'><a href="ModelStore.html#ready">ready</a></li><li data-type='method'><a href="ModelStore.html#saveMigration">saveMigration</a></li><li data-type='method'><a href="ModelStore.html#saveRecord">saveRecord</a></li><li data-type='method'><a href="ModelStore.html#saveSchema">saveSchema</a></li></ul></li></ul><h3>Namespaces</h3><ul><li><a href="conforms.html">conforms</a><ul class='methods'><li data-type='method'><a href="conforms.html#.conforms">conforms</a></li></ul></li><li><a href="diff.html">diff</a><ul class='methods'><li data-type='method'><a href="diff.html#.apply">apply</a></li><li data-type='method'><a href="diff.html#.applyDiff">applyDiff</a></li><li data-type='method'><a href="diff.html#.create">create</a></li><li data-type='method'><a href="diff.html#.createDiff">createDiff</a></li><li data-type='method'><a href="diff.html#.makeChangeHandler">makeChangeHandler</a></li><li data-type='method'><a href="diff.html#.reverse">reverse</a></li><li data-type='method'><a href="diff.html#.reverseDiff">reverseDiff</a></li></ul></li><li><a href="equals.html">equals</a><ul class='methods'><li data-type='method'><a href="equals.html#.equals">equals</a></li></ul></li><li><a href="Errors.html">Errors</a></li><li><a href="html.html">html</a></li><li><a href="schema.html">schema</a><ul class='methods'><li data-type='method'><a href="schema.html#.createDefault">createDefault</a></li><li data-type='method'><a href="schema.html#.createValidator">createValidator</a></li><li data-type='method'><a href="schema.html#.getModelSet">getModelSet</a></li><li data-type='method'><a href="schema.html#.getRecordNameFor">getRecordNameFor</a></li><li data-type='method'><a href="schema.html#.linkSchema">linkSchema</a></li><li data-type='method'><a href="schema.html#.migrate">migrate</a></li><li data-type='method'><a href="schema.html#.migrate%255E2">migrate^2</a></li><li data-type='method'><a href="schema.html#.unlinkSchema">unlinkSchema</a></li><li data-type='method'><a href="schema.html#.validate">validate</a></li></ul></li><li><a href="tree.html">tree</a></li><li><a href="utils.html">utils</a><ul class='methods'><li data-type='method'><a href="utils.html#.sortedObjectKeys">sortedObjectKeys</a></li></ul></li></ul>
</nav>

<div id="main">
    
    <h1 class="page-title">models/model-registry.js</h1>
    

    



    
    <section>
        <article>
            <pre class="prettyprint source linenums"><code>import { CouldNotFindModel, SchemaMismatchForModel } from "../errors.js";
import { createDiff } from "../diff/diff.js";
import * as migrations from "../migration/make-migration.js";
import * as basicSchema from "../schema/basic-js-schema.js";

/**
 * The model registry contains the list of current model-associated schema objects.
 * @ignore
 */
class ModelRegistry {
  constructor() {
    this.store = undefined;
    this.resetRegistrations();
  }

  setStore(store) {
    this.store = store;
  }

  resetRegistrations() {
    this.REGISTER = {};
  }

  /**
   * Get a previously registered schema, or throw because
   * the calling code assumes a registration already happened,
   * so if we can't find it, that's a true error.
   * @param {*} modelName
   * @returns {schema} The previously stored schema for a given model.
   */
  getRegisteredSchema(modelName) {
    const schema = this.REGISTER[modelName];
    if (!schema) {
      throw new CouldNotFindModel(modelName);
    }
    return schema;
  }

  /**
   * Record the model singleton for schema-related work,
   * and try to tie this into the associated schema known
   * to the storage backend.
   */
  recordModelClassSync(BaseModel) {
    const { REGISTER } = this;
    const modelSet = basicSchema.getModelSet(BaseModel);
    modelSet.forEach((Model) => {
      REGISTER[Model.name] = Model.schema = new Model(this, Date.now());
    });
    return REGISTER[BaseModel.name];
  }

  /**
   * Record the model singleton for schema-related work,
   * and try to tie this into the associated schema known
   * to the storage backend.
   */
  async recordModelClassAsync(BaseModel) {
    await this.recordModelClassWithStoreBacking(BaseModel);
    return this.REGISTER[BaseModel.name];
  }

  /**
   * Record the model singleton for schema-related work,
   * and tie this into the associated schema known to the
   * storage backend.
   *
   * - If no saved schema, save one.
   * - If saved schema matches, nice.
   * - If it does not, save a version-bumped schema
   *   and create a migration file.
   */
  async recordModelClassWithStoreBacking(BaseModel) {
    const { store, REGISTER } = this;

    // How many distinct models are involved here?
    const modelSet = basicSchema.getModelSet(BaseModel);

    // Run through each of them, and generate migrations, if
    // needed, for each model that has a schema-mismatch with its
    // previously stored schema (if there was one, of course).
    const diffList = [];

    // Run in smallest-to-largest order, with the base model last.
    const handleModel = async (Model) => {
      const modelName = Model.name;
      let schema = new Model(this, Date.now());

      // Is this the same schema as was previously stored?
      let stored = REGISTER[modelName];

      // Is this a schema that may be stored at some backend? If so,
      // see if there are differences compared to the stored version.
      if (schema.__meta.distinct) {
        if (!stored) {
          stored = await store.loadSchema(schema);
        }

        if (stored) {
          if (stored.__meta.version === undefined) {
            Object.defineProperty(stored.__meta, `version`, {
              enumerable: false,
              value: 1,
            });
          }

          // Create diff, but filter out functions (e.g. `validate`) because those
          // cannot be stored in schema, those will always come from the Model class.
          const diffs = createDiff(stored, schema).filter(
            (v) => !v.value || typeof v.value !== `function`
          );

          if (diffs.length > 0) {
            Object.defineProperty(schema.__meta, `version`, {
              enumerable: false,
              value: stored.__meta.version + 1,
            });

            // It is not! Someone's going to have to run data migrations
            // before this model can be safely used with preexisting data.
            // So let's be nice: save the new schema to file and create a
            // migration runner so that the data can be uplifted.
            diffList.push({ Model, stored, schema, operations: diffs });
          } else {
            Object.defineProperty(schema.__meta, `version`, {
              enumerable: false,
              value: stored.__meta.version,
            });
          }
        } else {
          // Use a new schema, because the above code will have
          // added runtime properties that would cause a schema
          // mismatch to be flagged.
          const schema = new Model(this, Date.now());
          Object.defineProperty(schema.__meta, `version`, {
            enumerable: false,
            value: 1,
          });
          await store.saveSchema(schema);
        }
      }

      REGISTER[modelName] = Model.schema = schema;
    };

    // Run through each model, one by one, despite being async.
    while (modelSet.length) await handleModel(modelSet.pop());

    // Process all "diffs" we accumulated.
    if (diffList.length > 0) {
      // generate all migration files
      const mfList = diffList.slice();
      while (mfList.length > 0) {
        const { stored, schema, operations } = mfList.shift();
        await this.generateMigrationFile(stored, schema, operations);
      }

      // Then save the updated schema files. We do things in this order because if
      // we save the updated schema files first, subsequent generateMigrationFile
      // calls don't see a "missing schema", and so don't write anything.
      const modelList = diffList.map((e) => e.Model);
      while (modelList.length) {
        const Model = modelList.shift();
        const schema = new Model(this, Date.now());
        // Use a new schema, because the above code will have
        // added runtime properties that would cause a schema
        // mismatch to be flagged.
        await store.saveSchema(schema);
      }

      // And then error we out.
      throw new SchemaMismatchForModel(BaseModel.name);

      // TODO: make these migrations "call each other" in some smartypants fashion instead.
    }
  }

  /**
   * Generate a migration file that can be run with Node to uplift
   * data files from one schema to another.
   *
   * FIXME: TODO: where do we house this? Should this go in storage-backend?
   */
  async generateMigrationFile(schema1, schema2, operations) {
    const migration = migrations.makeMigration(
      schema1,
      schema2,
      undefined,
      operations
    );
    await this.store.saveMigration(schema1, schema2, migration);
  }
}

const registry = new ModelRegistry();
export { registry };
</code></pre>
        </article>
    </section>




    
    
</div>

<br class="clear">

<footer>
    Documentation generated by <a href="https://github.com/jsdoc3/jsdoc">JSDoc 3.6.7</a> on Fri Nov 12 2021 12:07:13 GMT-0800 (Pacific Standard Time) using the <a href="https://github.com/clenemt/docdash">docdash</a> theme.
</footer>

<script>prettyPrint();</script>
<script src="scripts/polyfill.js"></script>
<script src="scripts/linenumber.js"></script>



</body>
</html>
