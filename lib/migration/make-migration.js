import { NothingToMigrate } from "../errors.js";
import { createDiff } from "../diff/diff.js";
import { makeSchemaChangeHandler } from "../schema/basic-js-schema.js";

// Determine whether we're running in CJS or ESM mode.
let IS_ESM = false;
try {
  IS_ESM = typeof import.meta !== `undefined`;
} catch (e) {}

// our script imports
const imports = IS_ESM
  ? `import { fileURLToPath } from "url";
import fs from "fs";
import path from "path";
import useModels from "use-models-for-data";
import { FileSystemStore } from "use-models-for-data/lib/models/store/filesystem-store.js";`
  : `const { fileURLToPath } = require("url");
const fs = require("fs");
const path = require("path");
const useModels = require("use-models-for-data");
const { FileSystemStore } = require("use-models-for-data/lib/models/store/filesystem-store.js");`;

// is the migration runner invoked or imported?
const invokedDirectly = IS_ESM
  ? `const nodePath = path.resolve(process.argv[1]);
const modulePath = path.resolve(fileURLToPath(import.meta.url));
const invokedDirectly = nodePath === modulePath;`
  : `const invokedDirectly = require.main === module;`;

// templated in later
async function processFile(filename, schemaName) {
  if (!invokedDirectly) return;

  if (!fs.existsSync(filename)) {
    console.error(`Could not find \${filename}`);
  }

  let data = fs.readFileSync(filename);

  try {
    data = JSON.parse(data.toString("utf-8"));
  } catch (e) {
    console.error(`Could not parse \${filename} as JSON`);
  }

  cache.clear(); // make sure each file's migration cache is clean
  const updated = useModels.diff.applyDiff(operations, data, changeHandler);

  const schemaPath = path.join(path.dirname(datapath), `..`);
  await FileSystemStore.bootstrap();
  const store = new FileSystemStore(schemaPath);
  const schema = store.getLatestSchema(schemaName);
  const validation = useModels.schema.validate(schema, updated);

  if (validation.passed) {
    const newData = JSON.stringify(updated, false, 2);
    if (writeInPlace) {
      fs.writeFileSync(filename, newData);
    } else {
      console.log(newData);
    }
  } else {
    console.log(`ERROR: Migrated data did not pass schema validation.
Please fill in the migration hooks to resolve the following errors:`);
    console.error(validation.errors);
  }
}

/**
 * Make sure we add a run-relevant file system API import.
 * @ignore
 */
export function finalizeMigration(script) {
  return `#!/usr/bin/node\n\n${script}`;
}

/**
 * Determine the series of operation transforms to turn schema1 into
 * schema2, and then turn that into a self-executing .js file that
 * users can edit before running, in case they need to fill in any of
 * the operational hooks.
 * @ignore
 */
export function makeMigration(
  schema1,
  schema2,
  schemaChangeHandler,
  operations
) {
  schemaChangeHandler = schemaChangeHandler ?? makeSchemaChangeHandler();
  const { ignoreKey } = schemaChangeHandler;

  operations = operations ?? createDiff(schema1, schema2);
  operations = operations.filter(({ key }) => !ignoreKey(key));
  if (operations.length === 0) throw new NothingToMigrate();

  // remove some values that have no meaning outside of the diffing process
  operations.forEach((op) => {
    delete op.stable;
    delete op.valueHash;
  });

  const runnerFileName = `${schema2.__meta.name}.v${schema1.__meta.version}.to.v${schema2.__meta.version}.js`;

  // Stubs for the forward migrations
  const forwardChangeHandlers = operations
    .map((op) => {
      if (!op.fn) return ``;
      // const dov = op.value?.default;
      // const cleanKey = op.key.replaceAll(`.shape`, ``);
      return `changeHandler.${op.fn} = function (object, op, options) {\n  //...\n};\n`;
    })
    .join(`\n`);

  // Stubs for the rollback migrations
  const rollbackChangeHandlers = operations
    .map((op) => {
      if (!op.rollback) return ``;
      return `changeHandler.${op.rollback} = function (object, op, options) {\n  //...\n};\n`;
    })
    .join(`\n`);

  // And finally, the actual file contents:

  return `${imports}
const changeHandler = useModels.schema.makeSchemaChangeHandler();

/**
 * [Forward migration hooks]
 *
 * In order to deal with relocated values, you can use the
 * "cache" object, which offers "cache.set(key,value)"" and
 * "cache.get(key)"" methods for storing and retrieving values
 * during a migration.
 *
 * This is particularly useful when dealing with relocations
 * where you can cache a value during the "remove" operation
 * and then assign it to its new location during the "add"
 * operation.
 */

${forwardChangeHandlers}

// [Rollback hooks]

${rollbackChangeHandlers}

// ================  DO NOT EDIT BELOW THIS LINE  ================

const howToRun = \`
Autogenerated executable runner for migrating data based on the
"${schema2.__meta.name}" schema from version ${
    schema1.__meta.version
  } to version ${schema2.__meta.version}.
${
  !(forwardChangeHandlers || rollbackChangeHandlers)
    ? ``
    : `
╔═══════════════════════════════════════════════════════════════════════════╗
║ A number of change handler functions have been included, which are called ║
║ during the migration process, and can be implemented to perform data      ║
║ processing outside of the migration itself.                               ║
╚═══════════════════════════════════════════════════════════════════════════╝`
}

Usage:

  1. node ${runnerFileName} targefile.json
  2. node ${runnerFileName} targefile.json --write
  3. node ${runnerFileName} targetdirectory --all

Mode 1: if a target file is indicated, the migration script will load in
the file and migrate its data, outputting the result to stdout

Mode 2: If the "--write" flag is provided, no data will be written to
stdout, instead rewriting the file itself in place.

Mode 3: If the "--all" flag is provided in combination with a directory
path, the script will load all .json files in the indicated directory and
process them as if running in mode 2.

Rollback usage:

  node ${runnerFileName} [...] --rollback

All three modes can be made to roll back a migration by using the
"--rollback" flag, which will rollback each step in the list of diff
operations, running them last-to-first.\`;

${invokedDirectly}

if (invokedDirectly && process.argv.length <= 2) {
  console.log(howToRun);
  
}

const operations = ${JSON.stringify(operations, false, 2)};

${IS_ESM ? `export { operations };` : `module.exports.operations = operations;`}

const cache = new (class {
  constructor() { this.clear(); }
  clear() { this.cache = {}; }
  get(k) { return this.cache[k]; }
  set(k, v) { this.cache[k] = v; }
});

const schemaName = \`${schema2.__meta.name}\`;
const datapath = process.argv[2];
const processAll = process.argv.includes("--all");
const writeInPlace = processAll || process.argv.includes("--write");

const rollback = process.argv.includes("--rollback");
if (rollback) reverseDiff(operations);

if (processAll) {
  fs.readdirSync(datapath)
    .filter(v => v.endsWith(".json"))
    .forEach(filepath => {
      console.log(filepath);
      processFile(datapath + "/" + filepath, schemaName);
    });
} else processFile(datapath, schemaName);

${processFile.toString()};
`;
}
